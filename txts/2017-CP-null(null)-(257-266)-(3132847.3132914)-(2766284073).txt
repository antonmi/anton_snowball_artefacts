DeepRank: A New Deep Architecture for Relevance Ranking in
Information Retrieval
Liang Pang†∗, Yanyan Lan†∗, Jiafeng Guo†∗, Jun Xu†∗, Jingfang Xu‡, Xueqi Cheng†∗
pl8787@gmail.com,{lanyanyan,guojiafeng,junxu,cxq}@ict.ac.cn,xujingfang@sogou-inc.com
†CAS Key Lab of Network Data Science and Technology, Institute of Computing Technology,
Chinese Academy of Sciences, Beijing, China
∗University of Chinese Academy of Sciences, Beijing, China
‡Sogou Inc, Beijing, China
ABSTRACT
Tis paper concerns a deep learning approach to relevance ranking
in information retrieval (IR). Existing deep IR models such as DSSM
and CDSSM directly apply neural networks to generate ranking
scores, without explicit understandings of the relevance. According
to the human judgement process, a relevance label is generated by
the following three steps: 1) relevant locations are detected; 2) local
relevances are determined; 3) local relevances are aggregated to
output the relevance label. In this paper we propose a new deep
learning architecture, namely DeepRank, to simulate the above
human judgment process. Firstly, a detection strategy is designed
to extract the relevant contexts. Ten, a measure network is applied
to determine the local relevances by utilizing a convolutional neural
network (CNN) or two-dimensional gated recurrent units (2D-GRU).
Finally, an aggregation network with sequential integration and
term gating mechanism is used to produce a global relevance score.
DeepRank well captures important IR characteristics, including
exact/semantic matching signals, proximity heuristics, query term
importance, and diverse relevance requirement. Experiments on
both benchmark LETOR dataset and a large scale clickthrough
data show that DeepRank can signifcantly outperform learning to
ranking methods, and existing deep learning methods.
CCS CONCEPTS
•Information systems →Retrieval models and ranking;
KEYWORDS
Deep Learning; Ranking; Text Matching; Information Retrieval
1
INTRODUCTION
Relevance ranking is a core problem of information retrieval. Given
a query and a set of candidate documents, a scoring function is
usually utilized to determine the relevance degree of a document
with respect to the query. Ten a ranking list is produced by sorting
in descending order of the relevance score. Modern learning to
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proft or commercial advantage and that copies bear this notice and the full citation
on the frst page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permited. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior specifc permission and/or a
fee. Request permissions from permissions@acm.org.
CIKM'17, November 6–10, 2017, Singapore.
© 2017 ACM. ISBN 978-1-4503-4918-5/17/11...$15.00
DOI: htp://dx.doi.org/10.1145/3132847.3132914
rank approach applies machine learning techniques to the rank-
ing function, which combines diferent kinds of human knowledge
(i.e. relevance features such as BM25 [27] and PageRank [22]) and
therefore has achieved great improvements on the ranking per-
formances [18]. However, a successful learning to rank algorithm
usually relies on efective handcrafed features for the learning
process. Te feature engineering work is usually time-consuming,
incomplete and over-specifed, which largely hinder the further
development of this approach [11].
Recently, deep learning approach [17] has shown great success
in many machine learning applications such as speech recognition,
computer vision, and natural language processing (NLP), owing to
their ability of automatically learning the efective data represen-
tations (features). Terefore, a new direction of Neural IR is pro-
posed to resort to deep learning for tackling the feature engineering
problem of learning to rank, by directly using only automatically
learned features from raw text of query and document. Tere have
been some pioneer work, including DSSM [13], CDSSM [29], and
DRMM [11]. Both DSSM and CDSSM directly apply deep neu-
ral networks to obtain the semantic representations of query and
document, and the ranking score is produced by computing their
cosine similarity. Guo et al. [11] argued that DSSM and CDSSM
only consider the semantic matching between query and document,
but ignore the more important relevance matching characteristics,
such as exact matching signals, query term importance, and diverse
matching requirement [27]. Tus they proposed another deep archi-
tecture, i.e. DRMM, to solve this problem. However, DRMM does
not explicitly model the relevance generation process, and fails
to capture important IR characteristics such as passage retrieval
intrinsics [19] and proximity heuristics [31].
Inspired by the human judgement process, we propose a new
deep learning architecture, namely DeepRank, to beter capture
the relevance intrinsics. According to the illustration in [33], the
human judgement process can be divided into three steps. Human
annotators frst scan the whole document to detect the relevant
locations. Ten the local relevance for each detected location is
decided. Finally, those local relevances are combined to form the
global relevance of the entire document. Consequently, DeepRank
contains three parts to simulate the human judgement process, by
tackling the following three problems:
Where does the relevance occur? According to the query-centric
assumption proposed in [33], the relevant information for a query
arXiv:1710.05649v2  [cs.IR]  22 Jul 2019
only locates in the contexts around query terms. Terefore, the con-
text with a query term at the center position, namely query-centric
context, is recognized as the relevant location in the detection step.
How to measure the local relevance? Afer the detection step,
a measure network is utilized to determine the local relevance
between query and each query-centric context. Firstly, a tensor
is constructed to incorporate both the word representations of
query/query-centric context, and the interactions between them.
Ten a CNN or 2D-GRU is applied on the tensor to output the
representation of the local relevance. In this way, important IR
characteristics such as exact/semantic matching signals, passage
retrieval intrinsics, and proximity heuristics can be well captured.
How to aggregate such local relevances to determine the global rele-
vance score? As shown by [33], two factors are important for user's
complex principles of aggregating local relevances, i.e. query term
importance [6] and diverse relevance requirement [27]. Terefore
we propose to frst aggregate local relevances at query term level,
and then make the combination by considering weights of diferent
terms, via a term gating network. To obtain the term level relevance,
we frst group the query-centric contexts with the same central
word together. Ten a recurrent neural network (RNN) such as
GRU [4] or LSTM [10] is utilized to aggregate such local relevances
sequentially, by further considering the position information of
these query-centric contexts in the whole document.
Above all, DeepRank is a new architecture composed of three
components, i.e. a detection strategy, a measure network with
CNN/2D-GRU, and an aggregation network with term gating and
RNN inside. Terefore, DeepRank can be trained end-to-end with
the pairwise ranking loss via stochastic gradient descent. We con-
duct experiments on both benchmark LETOR4.0 data and a large
scale clickthrough data collected from a commercial search engine.
Te experimental results show that: 1) Existing deep IR methods
such as DSSM, CDSSM, and DRMM perform much worse, if using
only automatically learned features, than the pairwise and listwise
learning to rank methods. 2) DeepRank signifcantly outperforms
not only all the existing deep IR models but also all the pairwise
and listwise learning to rank baseline methods. 3) If we incorporate
handcrafed features into the model, as did in SQA [28], DeepRank
will be further improved, and the performance is beter than SQA.
We also conduct a detailed experimental analysis on DeepRank to
investigate the infuences of diferent setings.
To the best of our knowledge, DeepRank is the frst deep IR
model to outperform existing learning to rank models.
2
RELATED WORK
We frst review related work on relevance ranking for IR, including
learning to rank methods and deep learning methods.
2.1
Learning to Rank Methods
In the past few decades, machine learning techniques have been
applied to IR, and gained great improvements to this area. Tis
direction is called learning to rank. Major learning to rank meth-
ods can be grouped into three categories: pointwise, pairwise and
listwise approach. Diferent approaches defne diferent input and
output spaces, use diferent hypotheses, and employ diferent loss
functions. Pointwise approach, such as logistic regression [8], in-
puts a feature vector of each single document and outputs the
relevance degree of each single document. Pairwise approach, such
as RankSVM [14] and RankBoost [7], inputs pairs of documents,
both represented by feature vectors and outputs the pairwise pref-
erence between each pair of documents. Listwise approach, such
as ListNet [2], AdaRank [34] and LambdaMart [1], inputs a set of
document features associated with query and outputs the ranked
list. All these approaches focus on learning the optimal way of
combining features through discriminative training. However, a
successful learning to rank algorithm relies on efective handcrafed
features for the learning process. Te feature engineering work
is usually time-consuming, incomplete and over-specifed, which
largely hinder the further development of this direction [11].
2.2
Deep Learning Methods
Recently, deep learning techniques have been applied to IR, for
automatically learning efective ranking features. Examples in-
clude DSSM [13], CDSSM [29], and DRMM [11]. DSSM uses a deep
neural network (DNN) to map both query and document to a com-
mon semantic space. Ten the relevance score is calculated as the
cosine similarity between these two vectors. Rather than using
DNN, CDSSM is proposed to use CNN to beter preserve the local
word order information when capturing contextual information
of query/document. Ten max-pooling strategies are adopted to
flter the salient semantic concepts to form a sentence level rep-
resentation. However, DSSM and CDSSM view IR as a semantic
matching problem, and focus on generating a good sentence level
representations for query and document. Tey ignore the important
intrinsics of relevance ranking in IR. Guo et al. [11] frst point out
the diferences between semantic matching and relevance matching.
Tey propose a new deep learning architecture DRMM to model
IR's own characteristics, including exact matching signals, query
terms importance, and diverse matching requirement. Specifcally,
DRMM frst builds local interactions between each pair of words
from query and document based on word embeddings, and then
maps the local interactions to a matching histogram for each query
term. Ten DRMM employs DNN to learn hierarchical matching
paterns. Finally, the relevance score is generated by aggregating
the term level scores via a term gating network. Tough DRMM
has made the frst step to design deep learning model specially for
IR, it does not explicitly model the relevance generation process of
human. It also fails to model the important IR intrinsics such as
passage retrieval strategies and proximity heuristics.
Another related sort of deep models, fourishing in NLP, provide
a new way of thinking if we treat IR task as a general text matching
task, i.e. query matches document. Tese work can be mainly cate-
gorized as representation focused models and interaction focused
models. Te representation focused models try to build a good
representation for each single text with a neural network, and then
conduct matching between the two vectors. Te DSSM and CDSSM
mentioned above belong to this category. Tere are also some other
ones such as ARC-I [12] model, which builds on word embeddings
and makes use of convolutional layers and pooling layers to ex-
tract compositional text representation. Te interaction focused
models frst build the local interactions between two texts, and
then use neural networks to learn the more complicated interaction
paterns for matching. Typical examples include ARC-II [12] and
MatchPyramid [23, 24], and Match-SRNN [32]. Tese models have
been shown efective in text matching tasks such as paraphrase
identifcation and question answering. DRMM can also be viewed
as an interaction focused model.
3
MOTIVATION
Te motivation of our deep architecture comes from the process
of human relevance judgement. As illustrated by [33], a human
annotator will frst examine the whole document for local relevance
information. Scanning involves iterating through every document
location, and deciding for each whether local relevance information
is found. As suggested by [33], if one can fnd relevant information
in a document, the relevant information must locate around the
query terms inside the document, namely query-centric assump-
tion. Finally, the local relevance for each query-centric context
is combined to form the relevance of the entire document. Fig-
ure ? gives an example to describe the process of human relevance
judgement, where user's information need is represented by the
query 'Hubble Telescope Achievements'. For a given document,
annotators will directly extract several contexts containing the key-
word 'Telescope' and 'Hubble', and determine whether they are
relevant to the query. Ten these local relevance information will
be considered together to determine the global relevance label of
the document with respect to the query.
Terefore, the relevance label is generated following three steps
in the human judgement process: 1) detection of relevant loca-
tions; 2) measurement of local relevance; 3) aggregation of local
relevances. Consequently, three problems are going to be tackled
if we want to well capture the relevance: (1) Where does the rele-
vance occur? (2) How to measure the local relevance? (3) How to
aggregate such local relevance to determine the fnal relevance la-
bel? Accordingly, we design our deep learning architecture, namely
DeepRank, to model the above relevance process.
4
DEEPRANK
In this section, we demonstrate a new deep learning architecture for
IR, namely DeepRank. DeepRank includes three parts to tackle the
above three problems: a Detection Strategy, a Measure Network, and
an Aggregation Network. In the detection step, the query-centric
contexts are extracted to represent where the relevance occur. In
the measurement step, CNN or 2D-GRU is adopted to measure
the local relevance between query and each query-centric context.
Finally in the aggregation step, RNN and a term gating network
are utilized to aggregate those local relevances to a global one for
ranking. Figure 1 gives an illustration of DeepRank.
We will frst give some mathematical notations. Each query and
document are represented as a sequence of word q = (w1, . . . ,wM)
and d = (v1, . . . ,vN ), where wi denotes the i-th word in the query
and vj denotes the j-th word in the document, respectively. Conse-
quently, we can use d(k)[p] = (vp−k, · · · ,vp, · · · ,vp+k) to denote
a piece of continuous text within a document, centered on the p-th
word with the sequence length 2k + 1. If we use word2vec tech-
nique [20] to represent each word to a vector, each word sequence
can be represented as a matrix. Taking query q = (w1, . . . ,wM)
for example, if the word embedding of wi is xi, the query will be
represented as Q = [x1, . . . , xM], where each column stands for a
word vector.
4.1
Detection Strategy
According to the query-centric assumption [33], the relevance usu-
ally occurs at the locations where the query terms appear in the
documents. Similar observations have also been obtained by the
eye-tracking studies [5], showing that annotators focus more on
the location of query terms when they are scanning the whole
document for relevance judgment. Terefore, we defne the query-
centric context as the relevant location, which is a context with a
query term at the center position. Mathematically, given a query q
and document d, if query term wu appears at the p-th position in
the document, i.e. wu = vp, the query-centric context centered on
this query term is represented as sp
u(k) = dk[p]. Afer the detection
step, we can obtain a set of word sequences {sp
u(k)}, with each one
represents a local relevant location.
4.2
Measure Network
Te goal of the measurement step is to determine the local rele-
vance, i.e. relevance between query and each query-centric context.
As reviewed in Section 2, previous deep learning models for text
matching can be divided into representation focused methods and
interaction focused methods. Te representation focused methods
focus on extracting high level semantic representations of texts,
starting from basic word representations. While the interaction
focused methods turn to directly model the interactions between
the two texts, starting from word-level interaction signals. In order
to combine the best of both approaches, we propose a new measure
network, as shown in Figure 2. Firstly a tensor is constructed as
the input. Ten CNN or 2D-GRU is applied on the tensor to output
a vector, which stands for the representation of local relevance. In
this way, the important IR characteristics such as exact/semantic
matching signals, passage retrieval intrinsics, and proximity heuris-
tics can be well captured in the measurement step.
4.2.1
Input Tensor. Te key idea of this layer is to feed both
the word representations of query/query-centric context and the
interactions between them into the input of the measure network.
Specifcally for a given query q and query-centric context sp
u(k)
with wu = vp, we denote the word-level interaction matrix used in
MatchPyramid [24] and Match-SRNN [32] as S, where each element
Sij is defned as the similarity of corresponding words wi and
vj. For example, indicator function or cosine similarity can be
used to capture the word-level exact or semantic matching signals,
respectively. Te mathematical formulas are shown as follows.
Sind
ij
= 1 if wi = vj, Sind
ij
= 0 otherwise,
(1)
Scos
ij
= xiT yj/(∥xi∥ · ∥yj∥),
(2)
where xi and yj denote the word embeddings of wi and vj, re-
spectively. To further incorporate the word representations of
query/query-centric context to the input, we extend each element
of Sij to a three-dimensional vector ˜Sij = [xi,yj,Sij]T . Terefore,
the original matrix S will become a three-order tensor, denoted as
S. In this way, the input tensor can be viewed as a combination of
Figure 1: An illustration of DeepRank.
Figure 2: An illustration of measure network for a query
and a query-centric context: (a) Input Tensor; (b) CNN; (c)
2D-GRU.
three matrices, i.e. query matrix, query-centric context matrix, and
word-level interaction matrix.
Based on the input tensor S, various neural networks can be
directly applied to obtain the representations for the local relevance
between query and query-centric context. In this paper, we choose
the CNN architecture in MatchPyramid and 2D-GRU architecture
in Match-SRNN, mainly because they have the ability to capture
important proximity heuristics for IR.
4.2.2
Convolutional Neural Network. In this paper, we use a one-
layer CNN in the measurement step, which includes a convolution
operation and a max-pooling operation defned as follows. Te
convolution operation can extract various matching paterns from
the input tensor S, by using diferent kinds of kernels, as shown in
Figure 2. Ten a max-pooling operation is used to flter signifcant
matching paterns for further relevance determination.
h(κ)
i,j =
3
�
l=1
γ −1
�
s=0
γ −1
�
t=0
w(κ)
s,t ·S(l)
i+s,j+t +b(κ),
h(κ) = max
i,j h(κ)
i,j , κ = 1, · · · ,K
(3)
where l denotes the l-th slide of the tensor, γ denotes the fxed size
of K diferent kernels, S(l)
i+s,j+t denote the (i +s, j +t) element of the
l-th matrix of the input tensor S, wκ
s,t and bκ denotes parameters.
Finally, all the signifcant matching paterns obtained from difer-
ent kernels are concatenated to form a vector, i.e. h = [h(1), · · · ,h(K)]T ,
to represent the local relevance. Tis vector will be treated as the
input to the aggregation network.
4.2.3
Two-Dimensional Gated Recurrent Units. Rather than us-
ing a hierarchical structure to capture the matching paterns, 2D-
GRU in Match-SRNN [32] adopts a diferent sequential model to
accumulate the matching signals. It is an extension of GRU [4]
(a typical variant of RNN) to two-dimensional data like matrix or
tensor1. Specifcally, 2D-GRU scans from top-lef to botom-right
(or in a bidirectional way) recursively. At each position, the hid-
den representation depends on the representations of the top, lef,
diagonal and current positions in the matrix. Te mathematical
formulas are shown as follows.
c = [hT
i−1,j, hT
i,j−1, hT
i−1,j−1, ST
ij]T ,
rθ = σ(W(rθ )c + b(rθ )), θ = l,t,d,
z′
ϕ = W(zϕ)c + b(zϕ), ϕ = m,l,t,d,
r = [rT
l , rT
t , rT
d ]T , [zm, zl, zt, zd] = RMax([z′
m, z′
l, z′
t, z′
d]),
h′
ij = ψ(WSij + U(r ⊙ [hT
i,j−1, hT
i−1,j, hT
i−1,j−1]T ) + b),
hij = zl ⊙ hi,j−1 + zt ⊙ hi−1,j + zd ⊙ hi−1,j−1 + zm ⊙ h′
ij,
(4)
where hij stands for the hidden representation at the (i, j)-th posi-
tion, zm, zl, zt, zd are the four gates, U, W, and b are parameters, σ
and ψ stand for sigmoid and tanh function respectively, and RMax
is a function to conduct sofmax on each dimension across gates,
[zϕ]j =
e[z′ϕ]j
e[z′m]j + e[z′l ]j + e[z′t ]j + e[z′d ]j , ϕ = m,l,t,d.
(5)
Te last hidden representation of 2D-GRU will be treated as the
output h, which is the botom right one at the matrix/tensor. If you
use a bi-directional 2D-GRU, both the top lef one −→h and botom
right one ←−h can be concatenated together to form the output vector,
i.e. h = [−→hT , ←−hT ]T .
1Strictly speaking, tensor is not a two-dimensional representation. However, 2D-GRU
can be directly applied on tensor by treating each element of the matrix as a vector.
Please note that both CNN and 2D-GRU well capture the proxim-
ity heuristics in IR. Proximity heuristic rewards a document where
the matched query terms occur close to each other, which is an im-
portant factor for a good retrieval model. For CNN, if the matched
query terms occur close to each other, appropriate kernels can be
utilized to extract such signifcant matching paterns and infuence
the relevance score. In this way, CNN well captures the proximity
heuristics. 2D-GRU can also model proximity. When there is a doc-
ument where the matched query terms occur close to each other,
the representation h will be strengthened by appropriately seting
gates and other parameters. As a result, the relevance score of the
document will be increased.
4.3
Aggregation Network
Afer the measurement step, we obtain a vector h to represent
the local relevance between query and each query-centric context.
Terefore, we need a further aggregation step to output a global
relevance score. In this process, two IR principles are going to be
considered in our deep architecture. One is query term importance:
query terms are critical to express user's information need and
some terms are more important than others [6]. Te other one is
diverse matching requirement: the distribution of matching paterns
can be quite diferent in a relevant document. For example, the
Verbosity Hypothesis assumes that the relevance matching might
be global. On the contrary, the Scope Hypothesis assumes that
the relevance matching could happen in any part of a relevant
document, and we do not require the document as a whole to be
relevant to a query. In order to capture the two IR principles, we
frst conduct a query term level aggregation, in which the diverse
matching requirement is taken into account. Ten a term gating
network is applied to capture the importance of diferent terms
when producing the global relevance score.
4.3.1
Qery Term Level Aggregation. In order to capture the
principle of diverse relevance requirement, we need to consider the
position of the corresponding query-centric context when conduct-
ing query term level aggregation. Terefore, we append each vector
h with the position indicator to encode the position information
of the corresponding query-centric context. Specifcally, diferent
position functions д(p) are utilized in our aggregation network:
Constant Function: д(p) = C,
C ∈ R,
Linear Function: д(p) = (L − p)/L,
L ∈ R,
Reciprocal Function: д(p) = a/(p + b),
a,b ∈ R, (6)
Exponential Function: д(p) = a · exp(−p/b),
a,b ∈ R,
where p stands for the position of the query-centric context, de-
termined by the central word vp. Afer this appending operation,
the representation of local relevance for a query-centric context
centered at word vp (denoted as h(p)) becomes [h(p)T ,д(p)]T .
To conduct query term level aggregation, we frst group h(p)
with the same central word together, which stands for all the local
relevances with respect to a same query term. Ten RNN is used to
integrate such local relevances by considering position information
into consideration. Tat is to say, we can obtain the global relevance
representation T(wu) for each query term wu as follows.
T(wu) =
pn
RNN
p=p1
�
hT (p),д(p)
�
, p1, . . .pn ∈ P(wu),
(7)
where P(wu) denotes the position set of all the query-centric con-
texts centered on query term wu. For example, you can use GRU [4]
to capture the sequential information, which is a typical variant
of RNN. In the experimental analysis, we show the comparisons
among diferent position functions.
4.3.2
Term Gating Network for Global Aggregation. Based on
query term level global relevance representations T(wu), we use
a term gating network (similar to that used in DRMM) to obtain
the fnal global relevance score, by considering importances of
diferent query terms. Specifcally, we defne a weight parameter
Ewu for each query term, and linear combine all the query term
level relevances as follows.
F (q, d) =
�
wu ∈q(Ewu I)T · T(wu),
(8)
where I is an vector with each element set to be 1, and the dimension
is set to be the same as T(wu).
4.4
Model Training
DeepRank is an end-to-end deep neural network, which can be
trained using stochastic gradient decent (SGD) methods, such as
Adam [16]. L2 regularization and early stopping strategy [9] are
also used in our implementation to deal with overfting. More
implementation details will be given in the experiments.
In our experiments, we use the following pairwise hinge loss for
training, since we are considering a ranking problem. For future
work, we are also willing to try other pairwise losses and listwise
loss functions to conduct the training process.
L(q, d+, d−) = max(0, 1 − F (q, d+) + F (q, d−)),
(9)
where L(q, d+, d−) denotes the pairwise loss between a pair of
positive and negative samples d+ and d−, and F (q, d) denotes the
relevance score produced by DeepRank.
5
EXPERIMENTS
In this section, we conduct extensive experiments to evaluate Deep-
Rank against state-of-the-art models, including learning to rank
methods, and existing deep learning methods. Te experimental
results on both LETOR4.0 benchmark [25] and a large scale click-
through data show that our model can signifcantly outperform all
the baselines, especially when other existing deep learning methods
perform much worse than learning to rank methods. Furthermore,
we give detailed experimental analysis to show more insights on
our model.
5.1
Experimental Settings
We frst introduce our experimental setings, including datasets,
baseline methods/implementations, and evaluation measures.
5.1.1
Data Sets. Since most deep models need to learn many
parameters, it is not appropriate to evaluate them with small tradi-
tional retrieval dataset, such as Robust04 and ClueWeb-09-Cat-B
used in [11], which have only less than 300 queries. In our ex-
periments, we use two datasets for evaluation, i.e. LETOR4.0 [25]
and a large scale clickthrough data. Te LETOR4.0 data is mainly
used for comparing our model with other deep models, and the
state-of-the-art learning to rank methods. Te clickthrough data is
larger, and we use it to compare diferent deep models.
LETOR4.0 dataset contains two separate data sampled from
the .GOV2 corpus using the TREC 2007 and TREC 2008 Million
Qery track queries, denoted as MQ2007 and MQ2008, respectively.
MQ2007 is a bit larger, which contains 1692 queries and 65,323
documents. While MQ2008 only contains 784 queries and 14,384
documents. Since the query number in MQ2008 is too small, which
will cause the serious insufcient training problem for deep learn-
ing models, we propose to merge the training set of MQ2007 to
that of MQ2008. Te validation and testing set are kept unchanged.
Ten we form a new large data set, still denoted as MQ2008. In total,
MQ2007 and MQ2008 contains 69,623 and 84,834 query-document
pairs, respectively. All the baselines are conducted fairly on this
new dataset for comparison. In original LETOR4.0, each query and
document pair is represented as a vector containing 46 diferent
features, which is easy for implementations of learning to rank
methods. While most deep IR models (except for SQA [28]) do not
use any handcrafed features, the raw text of query and document
are used for implementation.
Te large scale clickthrough data, namely ChineseClick, is col-
lected from a commercial Chinese search engine. In the data collec-
tion process, the user is given the top 10 results for each proposed
query. Clicked documents are viewed to be relevant, and the other
ones are viewed as irrelevant. Since this is a Chinese dataset, we
frst conduct word segmentation for queries and documents. Ten
we apply some typical data preprocessing techniques, such as navi-
gational queries fltering, stopping words and low frequency words
(less than 50) removing. Afer these preprocessing, the fnal dataset
contains 12,520 queries, 115,562 documents, and 118,835 query-
document pairs. It is further divided into training/validation/testing
set according to the proportion 3:1:1 of query numbers.
5.1.2
Baseline Methods. We adopt two types of baseline meth-
ods for comparison, including learning to rank methods and deep
learning methods.
For learning to rank approach, we compare both pairwise and list-
wise ranking methods. Te pairwise baselines include RankSVM [14]
and RankBoost [7], which apply SVM and boosting techniques to
the pairwise ranking problem, respectively. Te listwise baselines
include AdaRank [34] and LambdaMart [1], where AdaRank pro-
poses to directly optimizing IR evaluation measures by boosting
to obtain a ranking list, and LamdaMart uses gradient boosting
for optimizing a listwise ranking loss, which is the winner of Ya-
hooLearning to Rank Challenge [3]. Tough the public results on
LETOR4.0 have included RankSVM, RankBoost and AdaRank as
the baselines, we are not able to conduct signifcant testing since
the ranking list and relevance scores are missing. Terefore, we
implement them on our own. Most of our results are comparable
with those on LETOR4.02. For RankSVM, we directly use the imple-
mentation in SVMrank [15]. RankBoost, AdaRank and LambdaMart
are implemented using RankLib3, which is a widely used tool in
2htp://research.microsof.com/en-us/um/beijing/projects/letor/letor4baseline.aspx
3htps://sourceforge.net/p/lemur/wiki/RankLib/
the area of learning to rank. For LETOR4.0 dataset, we use 46 di-
mensional standard features provided for public to evaluate the
performance of learning to rank approaches. BM25-Title which
calculate BM25 score between query and document title, is one of
the powerful feature among these features.
For deep learning approach, we compare three existing deep
IR models, i.e. DSSM [13], CDSSM [29], and DRMM [11]. We also
compare some popular deep methods for text matching, includ-
ing one representation focused method, i.e. ARC-I [12], and three
interaction focused methods, i.e. ARC-II [12], MatchPyramid [24],
and Match-SRNN [32]. Implementation details are listed as follows.
Firstly, all the word embeddings in these methods are learned with
the Continuous Bag-of-Words (CBOW) model [20] from Wikipedia
corpus, and the dimension is set to 50. In general, most deep learn-
ing baselines are applied following the original implementations.
We only reduce the parameter numbers due to the relative small
size of our data. For example, we use a three-layer DNN as that in
the original paper of DSSM, and the node number of each layer is re-
duced to 100, 100, and 50. For CDSSM, we use a one-layer CNN with
50 (1 × 3) kernels. Terefore, a 50-dimensional vector is obtained
afer global pooling strategy. DRMM is directly implemented using
the best confguration and the code released by [11]. For ARC-I, we
use a two-layer CNN with each one containing 16 (1 × 3) kernels.
Te size of pooling in the frst layer is set to 2, while the size of
pooling in the last layer is set to be 2 for query representation, and
20 for document representation, respectively. For ARC-II, we use a
two-layer CNN, where there are 8 kernels in each layer. Te size
of kernels and pooling in both layers are set to (1 × 3)/(3 × 3) and
(2 × 2)/(2 × 20), respectively. For MatchPyramid, we use cosine
similarity to construct the word-level interaction matrix. Ten a
one-layer CNN is applied on the matrix with 8 (3 × 3) kernels, and
the size of dynamic pooling is set to (3 × 10). For Match-SRNN,
2D-GRU is directly applied on the same interaction matrix, and the
dimension of hidden node is set to 2.
SQA [28] model combines handcraf features in the learning
process, therefore it is not appropriate to directly compare it with
DeepRank, which only uses automatically learned feature from raw
text for ranking. For fair comparison, we delete the handcrafed
features in SQA and obtain a pure deep SQA model, denoted as
SQA-noFeat. Furthermore, we incorporate the handcrafed features
(46 default features in LETOR4.0) into the last layer of DeepRank
to obtain DeepRank-Feat, which is used to compare with SQA. For
both SQA-noFeat and SQA, one-layer CNN with 50 (1 × 3) kernels
is used in the deep architecture.
Te DeepRank4 for performance comparison is implemented
using the following setings: the window size of query-centric con-
text is set to 15; cosine similarity is adopted to construct the input
tensor; both CNN and 2D-GRU are used in the measurement step,
therefore we have two versions of DeepRank, denoted as DeepRank-
CNN and DeepRank-2DGRU; the reciprocal function is used as the
positional function, and GRU is adopted in the aggregation step. We
also compare diferent setings of DeepRank for detailed analysis.
5.1.3
Evaluation Measures. For the evaluation on LETOR4.0, we
follow the data partitions on this dataset (5-fold) and the average
results are reported. While for the evaluation on ChineseClick,
4Te source code: htps://github.com/pl8787/textnet-release.
we train the model on the training set, tune hyper-parameters
on the validation set and report the results on the testing set for
comparison. Tree evaluation measures [26] are used in this paper,
i.e. Precision, NDCG, and MAP. Furthermore, we conduct a pairwise
t-test [30] for signifcance testing with p-value lower than 0.05
(i.e. p-value≤ 0.05).
5.2
Performance Comparison
Te performance comparison results of DeeRank against baseline
models are shown in Table 1.
5.2.1
Performance Comparison on LETOR 4.0. From the results
on MQ2007 and MQ2008, we can see that: 1) None of existing deep
learning models could perform comparably with learning to rank
methods. Some of them are even worse than BM25. Te results tell
us that the automatically learned features in existing deep learning
models are not beter than traditional extracted ones, though they
are using more complex models for training. Someone may argue
that the experimental fndings are inconsistent with previous stud-
ies that DSSM and CDSSM can signifcantly outperform traditional
retrieval models, as stated in [13] and [29]. Te reason lies in that
LETOR4.0 is much smaller than the clickthrough data used in [13]
and [29]. In the following experiments on ChineseClick, we can
see that all the deep models perform beter than BM25. Terefore,
deep models usually need more data for optimization, which is
also the reason why we do not use Robust04 and ClueWeb-09-CAt-
B used in [11] for evaluation. 2) As for the comparisons between
these deep models, interaction focused ones such as DRMM, ARC-II,
MatchPyramid and Match-SRNN perform much beter than repre-
sentation focused ones such as DSSM, CDSSM, ARC-I, and SQA-
noFeat. Tis is consistent with the understanding that interaction
signals are much more important than the semantic representation
of query/document in IR, as described in [11]. Furthermore, DRMM
performs the best among all the deep learning baseline methods.
Tis is because DRMM further incorporate IR characteristics into
their architecture, which indicate the importance of capturing IR
intrinsics in the architecture design process. 3) Our DeepRank not
only signifcantly outperforms the deep learning baselines, but also
signifcantly improves the results of learning to rank methods, even
only use the query and document raw text data. For example, the
improvement of DeepRank-CNN against the best deep learning
baseline (i.e. DRMM) on MQ2007 is 16.1% w.r.t. NDCG@1, 12.9%
w.r.t. P@1, and 6.4% w.r.t. MAP, respectively; while the improve-
ment of DeepRank-CNN against the best learning to rank method
(i.e. LambdaMart) on MQ2007 is 7.0% w.r.t. NDCG@1, 5.6% w.r.t.
P@1, and 6.2% w.r.t. MAP, respectively. Te results indicate that
by appropriately modeling relevance, deep learning approach can
signifcantly outperform learning to rank approach for IR applica-
tion. 4) Tough SQA has used both automatically learned features
and handcrafed features, the performance cannot compare with
DeepRank by using only automatically learned features for ranking.
If we incorporate handcrafed features into DeepRank, the perfor-
mance will be further improved, as shown in DeepRank-CNN-Feat.
Te results demonstrate the superiority of our deep architecture.
5.2.2
Performance Comparison on ChineseClick. Te ChineseClick
data is used to compare DeepRank with other deep learning meth-
ods. We do not include the DSSM and CDSSM baselines. Tat is
because DSSM and CDSSM are specially designed for English data,
and leter-trigram is used as the input of neural network, which
is not applicable for Chinese data. If we are using the whole word
embedding as the input, CDSMM will become the same as ARC-I.
Terefore, we omit CDSSM and directly report the results of ARC-I
for comparison. Te results show that deep learning baselines per-
form comparably with BM25, some are even beter. Tat is because
we are using a larger data, the training of deep models become
more sufcient and the performances are improved. Our DeepRank
still performs the best. Te improvement against the BM25 is about
21.0% w.r.t. NDCG@1, and 11.5% w.r.t. MAP. While the improve-
ment against the best deep learning baseline (i.e. Match-SRNN) is
about 11.0% w.r.t. NDCG@1, and 4.3% w.r.t. MAP.
From the above results, we conclude that DeepRank signifcantly
improves the results of relevance ranking, with architecture spe-
cially designed to model human's relevance generation process.
5.3
Detailed Analysis of DeepRank
DeepRank is such a fexible deep architecture that diferent param-
eter setings and neural networks can be used in the detection,
measurement, and aggregation steps. Some of these setings may
largely infuence the fnal ranking performances. Terefore, we
conduct a detailed analysis on MQ2007 to show the comparisons of
DeepRank with diferent setings, with expect to give some insights
for implementation. Specifcally, we analyze four factors, i.e. win-
dow size of query-centric context in the detection step, input tensor
in the measurement step, neural network in the measurement step,
positional function in the aggregation step. We change one factor of
the above DeepRank-CNN each time to conduct the comparisons.
5.3.1
Impact of Diferent Window Sizes of Qery-Centric Context.
Te window size of query-centric context determines the scope
of local relevance in the human judgment process. With a small
window size, users would determine local relevance with less efort
since contexts are short, but it is easy to introduce ambiguity due to
limited context information. When window size is large, there are
sufcient contexts to facilitate the precise local relevance judgment,
but the cost is also increased and many noises may infuence the
judgment. We conduct an experiment to compare diferent window
sizes of query-centric context, varying in the range of 1, 7, 11, 15,
19 and 23. Te results listed at the top of Table 2 show that the per-
formances of DeepRank frst increase and then become stable, with
the increase of window size. Te best performance is obtained with
window size up to 11/15 (w.r.t diferent evaluation measures). Tere-
fore, with considering the computational complexity, we suggest
to use a comparable medium window size in real application, and
the exact number need to be tuned considering averaged document
length, query length, and data size.
5.3.2
Impact of Diferent Input Tensors. In order to capture both
word representations of query/query-centric context and their in-
teractions, we propose to construct a three-order tensor S as the
input of the measure network. Here, we compare four diferent
setings of tensor. Sind
I
and Scos
I
stand for the case when we use
Table 1: Performance comparison of diferent models on MQ2007, MQ2008 and ChineseClick. Signifcant performance degra-
dation with respect to DeepRank-CNN is denoted as (-) with p-value ≤ 0.05.
MQ2007
Model
NDCG@1
NDCG@3
NDCG@5
NDCG@10
P@1
P@3
P@5
P@10
MAP
BM25-Title
0.358−
0.372−
0.384−
0.414−
0.427−
0.404−
0.388−
0.366−
0.450−
RankSVM
0.408−
0.405−
0.414−
0.442−
0.472−
0.432−
0.413−
0.381−
0.464−
RankBoost
0.401−
0.404−
0.410−
0.436−
0.462−
0.428−
0.405−
0.374−
0.457−
AdaRank
0.400−
0.410−
0.415−
0.439−
0.461−
0.431−
0.408−
0.373−
0.460−
LambdaMart
0.412−
0.418−
0.421−
0.446−
0.481−
0.444−
0.418−
0.384−
0.468−
DSSM
0.290−
0.319−
0.335−
0.371−
0.345−
0.359−
0.359−
0.352−
0.409−
CDSSM
0.288−
0.288−
0.297−
0.325−
0.333−
0.309−
0.301−
0.291−
0.364−
Arc-I
0.310−
0.334−
0.348−
0.386−
0.376−
0.377−
0.370−
0.364−
0.417−
SQA-noFeat
0.309−
0.333−
0.348−
0.386−
0.375−
0.373−
0.372−
0.364−
0.419−
DRMM
0.380−
0.396−
0.408−
0.440−
0.450−
0.430−
0.417−
0.388−
0.467−
Arc-II
0.317−
0.338−
0.354−
0.390−
0.379−
0.378−
0.377−
0.366−
0.421−
MatchPyramid
0.362−
0.364−
0.379−
0.409−
0.428−
0.404−
0.397−
0.371−
0.434−
Match-SRNN
0.392−
0.402−
0.409−
0.435−
0.460−
0.436−
0.413−
0.384−
0.456−
DeepRank-2DGRU
0.439
0.439
0.447
0.473
0.513
0.467
0.443
0.405
0.489
DeepRank-CNN
0.441
0.447
0.457
0.482
0.508
0.474
0.452
0.412
0.497
SQA
0.423
0.432
0.442
0.466
0.491
0.463
0.443
0.404
0.479
DeepRank-CNN-Feat
0.446
0.457
0.462
0.489
0.518
0.483
0.451
0.412
0.502
MQ2008
Model
NDCG@1
NDCG@3
NDCG@5
NDCG@10
P@1
P@3
P@5
P@10
MAP
BM25-Title
0.344−
0.420−
0.461−
0.220−
0.408−
0.381−
0.337−
0.245−
0.465−
RankSVM
0.375−
0.431−
0.479−
0.229
0.441−
0.390−
0.348−
0.249
0.478−
RankBoost
0.381
0.436−
0.477−
0.231
0.455
0.392−
0.347−
0.248
0.481−
AdaRank
0.360−
0.422−
0.462−
0.222
0.430−
0.384−
0.339−
0.247−
0.468−
LambdaMart
0.378
0.437−
0.477−
0.231
0.446−
0.398
0.348−
0.251
0.478−
DSSM
0.286−
0.336−
0.378−
0.178−
0.341−
0.307−
0.284−
0.221−
0.391−
CDSSM
0.283−
0.331−
0.376−
0.175−
0.335−
0.302−
0.279−
0.222−
0.395−
Arc-I
0.295−
0.363−
0.413−
0.187−
0.361−
0.336−
0.311−
0.229−
0.424−
SQA-noFeat
0.291−
0.350−
0.401−
0.184−
0.366−
0.332−
0.309−
0.231−
0.416−
DRMM
0.368−
0.427−
0.468−
0.220−
0.437−
0.392−
0.344−
0.245−
0.473−
Arc-II
0.299−
0.340−
0.394−
0.181−
0.366−
0.326−
0.305−
0.229−
0.413−
MatchPyramid
0.351−
0.401−
0.442−
0.211−
0.408−
0.365−
0.329−
0.239−
0.449−
Match-SRNN
0.369−
0.426−
0.465−
0.223−
0.432−
0.383−
0.335−
0.239−
0.466−
DeepRank-2DGRU
0.391
0.436
0.480
0.236
0.462
0.395
0.354
0.252
0.489
DeepRank-CNN
0.406
0.460
0.496
0.240
0.482
0.412
0.359
0.252
0.498
SQA
0.402
0.454
0.493
0.236
0.485
0.411
0.362
0.254
0.496
DeepRank-CNN-Feat
0.418
0.475
0.507
0.248
0.497
0.422
0.366
0.255
0.508
ChineseClick
Model
NDCG@1
NDCG@3
NDCG@5
NDCG@10
P@1
P@3
P@5
P@10
MAP
BM25
0.200−
0.320−
0.412−
0.280−
0.200−
0.174−
0.169−
0.152
0.373−
Arc-I
0.208−
0.359−
0.451−
0.286−
0.208−
0.193−
0.180−
0.153
0.393−
SQA-noFeat
0.232−
0.368−
0.458−
0.292−
0.232−
0.194−
0.180−
0.153−
0.403−
DRMM
0.218−
0.346−
0.442−
0.288−
0.218−
0.185−
0.177−
0.153
0.392−
Arc-II
0.190−
0.329−
0.430−
0.283−
0.190−
0.180−
0.177−
0.153
0.373−
MatchPyramid
0.204−
0.342−
0.436−
0.285−
0.204−
0.184−
0.178−
0.153
0.384−
Match-SRNN
0.218−
0.360−
0.456−
0.295−
0.218−
0.190−
0.181−
0.153
0.399−
DeepRank-2DGRU
0.244
0.382
0.473
0.299
0.244
0.205
0.185
0.153
0.415
DeepRank-CNN
0.242
0.386
0.476
0.298
0.242
0.202
0.185
0.153
0.416
Table 2: Performance comparisons of DeepRank with difer-
ent settings on MQ2007.
Model
NDCG@1
NDCG@5
MAP
DeepRank-W1
0.422
0.425
0.470
DeepRank-W7
0.426
0.444
0.490
DeepRank-W11
0.438
0.458
0.495
DeepRank-W15
0.441
0.457
0.497
DeepRank-W19
0.430
0.453
0.496
DeepRank-W23
0.441
0.455
0.496
DeepRank-Sind
I
0.416
0.427
0.473
DeepRank-Scos
I
0.411
0.430
0.479
DeepRank-SR
0.425
0.439
0.482
DeepRank-Scos
IR
0.441
0.457
0.497
DeepRank-DNN
0.383
0.414
0.471
DeepRank-2DGRU
0.440
0.447
0.489
DeepRank-CNN
0.441
0.457
0.497
DeepRank-Const
0.384
0.419
0.473
DeepRank-Linear
0.431
0.445
0.492
DeepRank-Exp
0.441
0.454
0.494
DeepRank-Recip
0.441
0.457
0.497
indicator or cosine function to construct the interaction matrix, and
omit the other two matrices in the tensor. SR stands for the case
that only word representations of query and query-centric context
is considered in the tensor, i.e. interaction matrix is ignored. Scos
IR
stands for the case when we use the three-order tensor, which is
exactly the DeepRank we used in the performance comparisons.
From the results listed in the second row of Table 2, we can see the
performances are improved when more information is modeled in
the tensor. Terefore, both word representations of query/query-
centric context and word-level interactions are important to the
relevance judgement.
5.3.3
Impact of Diferent Measure Networks. Te measure net-
work is adopted to determine the relevance between query and a
detected query-centric context. In the model section, we demon-
strate how to use CNN and 2D-GRU to conduct such measurement,
mainly because these two kinds of neural networks have the ability
to capture the proximity heuristics. Of course, you can also use
other deep learning architectures, such as DNN. In this section, we
conduct experiments on MQ2007 to compare the three diferent ver-
sions of DeepRank, denoted as DeepRank-DNN, DeepRank-CNN,
and DeepRank-2DGRU. Te experimental results in the third row of
Table 2 show that DeepRank-CNN and DeepRank-2DGRU perform
much beter than DeepRank-DNN. Te reason lies in that CNN
and 2D-GRU both have the ability to model the proximity heuris-
tics, while DNN cannot because it is position sensitive, which is
contradict with the position independent proximity heuristic.
5.3.4
Impact of Diferent Position Functions. As described in the
aggregation network, diferent kinds of position functions can be
used to model the position importance. Here we compare Deep-
Rank with four diferent position functions, i.e. Constant, Linear,
Reciprocal, and Exponential functions, denoted as DeepRank-Const,
DeepRank-Linear, DeepRank-Recip and DeepRank-Exp, respec-
tively. Te results listed in the fourth row of Table 2 show that
DeepRank-Recip is the best, while DeepRank-Const is the worst.
As for the other two functions, DeepRank-Exp perform comparable
with DeepRank-Recip, and DeepRank-Linear is a litle worse than
DeepRank-Recip and DeepRank-Exp. Te results indicate that top
positions are more important, which is consistent with many previ-
ous studies for relevance ranking in IR [21]. As for the reason why
reciprocal and exponential function performs beter than linear
function, we think this is because MQ2007 is extracted from GOV
data, where title and abstraction information may play a dominant
role in determining the relevance. Terefore, the functions with
a long tail, as that in reciprocal or exponential function, will be
favored. To sum up, the position function plays an important role
in DeepRank, and users should pay more atention to the choice,
which need to be conducted by considering the characteristics of
diferent applications.
5.3.5
Relations to Previous Models. We also would like to point
out that DeepRank has a close relationship with previous models,
such as BM25, MatchPyramid, and Match-SRNN. With some sim-
plifcation, DeepRank can reduce to (or approximate) these models.
BM25 is a bag-of-words retrieval model that ranks a set of docu-
ments based on the query terms appearing in each document, re-
gardless of the inter-relationships between the query terms within
a document. Te most common form is given as follows.
BM25(q, d) =
�
w ∈q
IDF(w) ·
f (w, d) · (k1 + 1)
f (w, d) + k1 · (1 − b + b |d|
avgdl)
(10)
where k1 and b are the hyper parameters, f (w, d) represents term
frequency of w in document d, IDF(w) represents inverse document
frequency of w, |d| denotes the document length and avgdl denotes
the averaged document length.
We are going to show that a simplifed DeepRank has the ability
to approximate BM25 function. Firstly, the window size of query-
centric context is set to 1. Ten the indicator function is used
to construct the input tensor, therefore word representations of
query/query-centric context are ignored. In this way, exact match-
ing signals are naturally captured, like in BM25. We can see that
the output of tensor will be a 0-1 vector, with only the elements at
the matched positions will be 1. If CNN is used in the measurement
step, we can omit the convolution layer and directly use the pooling
strategy to output the value 1; while if 2D-GRU is used, we can also
output the value 1 by appropriately seting gates and parameters.
As a consequence, the output of the measure network will be 1 for
each query-centric context. At the aggregation step, we set the
position function as a constant д(p) = 1/|d|, and term weight as
the IDF value, i.e. Ewu = IDF(wu). Terefore, the output of this
DeepRank can be viewed as the following function:
DeepRank(q, d) =
�
w ∈q
IDF(w) · RNN
p ∈P(w)
�
1, 1/|d|
�
=
�
w ∈q
IDF(w) · G(f (w, d), |d|),
(11)
where the second equation is obtained because RNN is an accumu-
lative process, and the function G is determined by the parameters
in RNN, learned from the training data. Te function G has high
capacities to approximate the functions in the formula of BM25
since there are many parameters. Terefore, a simplifed version of
DeepRank can well approximate the BM25 model.
In addition, DeepRank has closer relationships with MatchPyra-
mid and Match-SRNN. If we set the window size of query-centric
context to be k = |d| and the weights of query term wu to be
1/f (wu, d), DeepRank reduces to MatchPyramid or Match-SRNN,
by using CNN or 2D-GRU as the measure network, respectively.
6
CONCLUSIONS AND FUTURE WORK
In this paper, we propose a new deep learning architecture, namely
DeepRank. Firstly, a detection strategy is designed to extract query-
centric contexts. A measure network is then applied to determine
the local relevance between query and each query-centric context,
by using CNN or 2D-GRU. Finally, an aggregation network is used
to produce the global relevance score, via RNN and a term gating
network. DeepRank not only well simulates the relevance gener-
ation process in human judgement, but also captures important
IR characteristics, i.e. exact/semantic matching signals, proximity
heuristics, query term importance, and diverse relevance require-
ment. We conduct experiments on both benchmark LETOR4.0 data
and a large clickthrough data. Te results show that DeepRank
signifcantly outperform learning to rank methods and existing
deep IR models, when most existing deep IR models perform much
worse than learning to rank methods. To the best of our knowledge,
DeepRank is the frst deep IR model to outperform existing learning
to rank models. We also give a detailed analysis on DeepRank to
show insights on parameter setings for implementation.
For future work, we plan to investigate the diferences between
the automatically learned representations of DeepRank and efec-
tive features used in learning to rank, which may introduce some
insights for architecture design of more powerful deep IR models.
7
ACKNOWLEDGMENTS
Tis work was funded by the 973 Program of China under Grant No.
2014CB340401, the National Natural Science Foundation of China
(NSFC) under Grants No. 61232010, 61433014, 61425016, 61472401,
and 61203298, and the Youth Innovation Promotion Association
CAS under Grants No. 20144310 and 2016102. Te authors would
like to thank Chengxiang Zhai (UIUC) and Yixing Fan (ICT, CAS) for
their valuable suggestions on this work, and Weipeng Chen (Sogou
Inc.) for providing helps on the data processing of ChineseClick.
REFERENCES
[1] Christopher JC Burges. 2010. From ranknet to lambdarank to lambdamart: An
overview. Learning 11 (2010), 23–581.
[2] Zhe Cao, Tao Qin, Tie-Yan Liu, Ming-Feng Tsai, and Hang Li. 2007. Learning to
rank: from pairwise approach to listwise approach. In ICML. ACM, 129–136.
[3] Olivier Chapelle and Yi Chang. 2011. Yahoo! learning to rank challenge overview.
In Proceedings of the Learning to Rank Challenge. 1–24.
[4] Kyunghyun Cho, Bart Van Merri¨enboer, Caglar Gulcehre, Dzmitry Bahdanau,
Fethi Bougares, Holger Schwenk, and Yoshua Bengio. 2014. Learning phrase
representations using RNN encoder-decoder for statistical machine translation.
In EMNLP. 1724–1734.
[5] Carsten Eickhof, Sebastian Dungs, and Vu Tran. 2015. An eye-tracking study of
query reformulation. In SIGIR. ACM, 13–22.
[6] Hui Fang, Tao Tao, and ChengXiang Zhai. 2004. A formal study of information
retrieval heuristics. In SIGIR. ACM, 49–56.
[7] Yoav Freund, Raj Iyer, Robert E Schapire, and Yoram Singer. 2003. An efcient
boosting algorithm for combining preferences. JMLR 4, Nov (2003), 933–969.
[8] Fredric C Gey. 1994. Inferring probability of relevance using the method of
logistic regression. In SIGIR. Springer, 222–231.
[9] Rich Caruana Steve Lawrence Lee Giles. 2001. Overfting in Neural Nets: Back-
propagation, Conjugate Gradient, and Early Stopping. In NIPS, Vol. 13. MIT Press,
402.
[10] Alan Graves, Abdel-rahman Mohamed, and Geofrey Hinton. 2013. Speech
recognition with deep recurrent neural networks. In ICASSP. IEEE, 6645–6649.
[11] Jiafeng Guo, Yixing Fan, Qingyao Ai, and W Bruce Crof. 2016. A deep relevance
matching model for ad-hoc retrieval. In CIKM. ACM, 55–64.
[12] Baotian Hu, Zhengdong Lu, Hang Li, and Qingcai Chen. 2014. Convolutional
neural network architectures for matching natural language sentences. In NIPS.
2042–2050.
[13] Po-Sen Huang, Xiaodong He, Jianfeng Gao, Li Deng, Alex Acero, and Larry
Heck. 2013. Learning deep structured semantic models for web search using
clickthrough data. In CIKM. ACM, 2333–2338.
[14] Torsten Joachims. 2002. Optimizing search engines using clickthrough data. In
SIGKDD. ACM, 133–142.
[15] Torsten Joachims. 2006. Training linear SVMs in linear time. In SIGIR. ACM,
217–226.
[16] Diederik Kingma and Jimmy Ba. 2014. Adam: A method for stochastic optimiza-
tion. arXiv preprint arXiv:1412.6980 (2014).
[17] Yann LeCun, Yoshua Bengio, and Geofrey Hinton. 2015. Deep learning. Nature
521, 7553 (2015), 436–444.
[18] Tie-Yan Liu. 2009. Learning to rank for information retrieval. Foundations and
Trends in Information Retrieval 3, 3 (2009), 225–331.
[19] Yuanhua Lv and ChengXiang Zhai. 2009. Positional language models for infor-
mation retrieval. In SIGIR. ACM, 299–306.
[20] Tomas Mikolov, Ilya Sutskever, Kai Chen, Greg S Corrado, and Jef Dean. 2013.
Distributed representations of words and phrases and their compositionality. In
NIPS. 3111–3119.
[21] Shuzi Niu, Jiafeng Guo, Yanyan Lan, and Xueqi Cheng. 2012. Top-k learning to
rank: labeling, ranking and evaluation. In SIGIR. ACM, 751–760.
[22] Lawrence Page, Sergey Brin, Rajeev Motwani, and Terry Winograd. 1999. Te
PageRank citation ranking: Bringing order to the web. Technical Report. Stanford
InfoLab.
[23] Liang Pang, Yanyan Lan, Jiafeng Guo, Jun Xu, and Xueqi Cheng. 2016. A study
of matchpyramid models on ad-hoc retrieval. In Neu-IR f16 SIGIR Workshop on
Neural Information Retrieval.
[24] Liang Pang, Yanyan Lan, Jiafeng Guo, Jun Xu, Shengxian Wan, and Xueqi Cheng.
2016. Text matching as image recognition. In AAAI. AAAI Press, 2793–2799.
[25] Tao Qin, Tie-Yan Liu, Jun Xu, and Hang Li. 2010. LETOR: A benchmark collection
for research on learning to rank for information retrieval. Information Retrieval
13, 4 (2010), 346–374.
[26] Stephen Robertson. 2000. Evaluation in information retrieval. In Lectures on
information retrieval. Springer, 81–92.
[27] Stephen E Robertson and Steve Walker. 1994. Some simple efective approxi-
mations to the 2-poisson model for probabilistic weighted retrieval. In SIGIR.
Springer-Verlag New York, Inc., 232–241.
[28] Aliaksei Severyn and Alessandro Moschiti. 2015. Learning to rank short text
pairs with convolutional deep neural networks. In Proceedings of SIGIR. ACM,
373–382.
[29] Yelong Shen, Xiaodong He, Jianfeng Gao, Li Deng, and Gr´egoire Mesnil. 2014.
Learning semantic representations using convolutional neural networks for web
search. In WWW. WWW, 373–374.
[30] Mark D Smucker, James Allan, and Ben Carterete. 2007. A comparison of
statistical signifcance tests for information retrieval evaluation. In CIKM. ACM,
623–632.
[31] Tao Tao and ChengXiang Zhai. 2007. An exploration of proximity measures in
information retrieval. In SIGIR. ACM, 295–302.
[32] Shengxian Wan, Yanyan Lan, Jiafeng Guo, Jun Xu, Liang Pang, and Xueqi Cheng.
2016. Match-SRNN: Modeling the Recursive Matching Structure with Spatial
RNN. In IJCAI. 2922–2928.
[33] Ho Chung Wu, Robert WP Luk, Kam-Fai Wong, and KL Kwok. 2007. A retro-
spective study of a hybrid document-context based retrieval model. Information
processing & management 43, 5 (2007), 1308–1331.
[34] Jun Xu and Hang Li. 2007. Adarank: a boosting algorithm for information
retrieval. In SIGIR. ACM, 391–398.
A
DATA PREPROCESSING
For pre-processing, all the words in documents and queries are
white-space tokenized, lower-cased, and stemmed using the Krovetz
stemmer. Stopword removal is performed on query and document
words using the INQUERY stop list. Words occurred less than 5
times in the collection are removed from all the document.
B
QUERY MATRIX & CONTEXT MATRIX
Te constructions of query matrix and context matrix are described
in detail below.
Sind
ij
= 1 if wi = vj, Sind
ij
= 0 otherwise,
Scos
ij
= xiT yj/(∥xi∥ · ∥yj∥),
where xi and yj denote the word embeddings of wi and vj, re-
spectively. To further incorporate the word representations of
query/query-centric context to the input, we extend each element
of Sij to a three-dimensional vector ˜Sij.
˜Sij = [xi,yj,Sij]T = [(WQxi)T , (WDyj)T ,Sij]T
where W Q and W D are the linear transformations that reducing
the higher dimensions of word embeddings into lower ones, for
example, from 50 dimensions to 2 dimensions.
Terefore, the original matrix S will become a three-order tensor,
denoted as S. In this way, the input tensor can be viewed as a
combination of three matrices, i.e. query matrix, query-centric
context matrix, and word-level interaction matrix.
C
CODE
We have released two versions of DeepRank. Te original one is
TextNet (htps://github.com/pl8787/textnet-release), the newer one
is implemented in PyTorch (htps://github.com/pl8787/DeepRank
PyTorch).
