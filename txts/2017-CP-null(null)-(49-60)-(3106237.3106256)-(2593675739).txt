Easy over Hard: A Case Study on Deep Learning
Wei Fu, Tim Menzies
Com.Sci., NC State, USA
wfu@ncsu.edu,tim.menzies@gmail.com
ABSTRACT
While deep learning is an exciting new technique, the benefts of
this method need to be assessed with respect to its computational
cost. Tis is particularly important for deep learning since these
learners need hours (to weeks) to train the model. Such long train-
ing time limits the ability of (a) a researcher to test the stability
of their conclusion via repeated runs with diferent random seeds;
and (b) other researchers to repeat, improve, or even refute that
original work.
For example, recently, deep learning was used to fnd which
questions in the Stack Overfow programmer discussion forum can
be linked together. Tat deep learning system took 14 hours to
execute. We show here that applying a very simple optimizer called
DE to fne tune SVM, it can achieve similar (and sometimes beter)
results. Te DE approach terminated in 10 minutes; i.e. 84 times
faster hours than deep learning method.
We ofer these results as a cautionary tale to the sofware analyt-
ics community and suggest that not every new innovation should
be applied without critical analysis. If researchers deploy some new
and expensive process, that work should be baselined against some
simpler and faster alternatives.
KEYWORDS
Search based sofware engineering, sofware analytics, parameter
tuning, data analytics for sofware engineering, deep learning, SVM,
diferential evolution
ACM Reference format:
Wei Fu, Tim Menzies. 2017. Easy over Hard: A Case Study on Deep Learning.
In Proceedings of 2017 11th Joint Meeting of the European Sofware Engineering
Conference and the ACM SIGSOFT Symposium on the Foundations of Sof-
ware Engineering, Paderborn, Germany, September 4-8, 2017 (ESEC/FSE'17),
12 pages.
DOI: 10.1145/3106237.3106256
1
INTRODUCTION
Tis paper extends a prior result from ASE'16 by Xu et al. [74]
(hereafer, XU). XU described a method to explore large programmer
discussion forums, then uncover related, but separate, entries. Tis
is an important problem. Modern SE is evolving so fast that these
forums contain more relevant and recent comments on current
technologies than any textbook or research article.
In their work, XU predicted whether two questions posted on
Stack Overfow are semantically linkable. Specifcally, XU defne
a question along with its entire set of answers posted on Stack
Overfow as a knowledge unit (KU). If two knowledge units are
ESEC/FSE'17, Paderborn, Germany
2017. 978-1-4503-5105-8/17/09...$15.00
DOI: 10.1145/3106237.3106256
semantically related, they are considered as linkable knowledge
units.
In their paper, they used a convolution neural network (CNN), a
kind of deep learning method [42], to predict whether two KUs are
linkable. Such CNNs are highly computationally expensive, ofen
requiring network composed of 10 to 20 layers, hundreds of millions
of weights and billions of connections between units [42]. Even
with advanced hardware and algorithm parallelization, training
deep learning models still requires hours to weeks. For example:
• XU report that their analysis required 14 hours of CPU.
• Le [40] used a cluster with 1,000 machines (16,000 cores) for
three days to train a deep learner.
Tis paper debates what methods should be recommended to
those wishing to repeat the analysis of XU. We focus on whether
using simple and faster methods can achieve the results that are cur-
rently achievable by the state-of-art deep learning method. Specif-
cally, we repeat XU's study using DE (diferential evolution [62]),
which serves as a hyper-parameter optimizer to tune XU's base-
line method, which is a conventional machine learning algorithm,
support vector machine (SVM). Our study asks:
RQ1: Can we reproduce XU's baseline results (Word Embedding +
SVM)? Using such a baseline, we can compare our methods to those
of XU.
RQ2: Can DE tune a standard learner such that it outperforms
XU's deep learning method? We apply diferential evolution to tune
SVM. In terms of precision, recall and F1-score, we observe that the
tuned SVM method outperforms CNN in most evaluation scores.
RQ3: Is tuning SVM with DE faster than XU's deep learning
method? Our DE method is 84 times faster than CNN.
We ofer these results as a cautionary tale to the sofware an-
alytics community. While deep learning is an exciting new tech-
nique, the benefts of this method need to be carefully assessed with
respect to its computational cost. More generally, if researchers
deploy some new and expensive process (like deep learning), that
work should be baselined against some simpler and faster alterna-
tives
Te rest of this paper is organized as follows. Section 2 describes
the background and related work on deep learning and parameter
tuning in SE. Section 3 explains the case study problem and the
proposed tuning method investigated in this study, then Section 4
describes the experimental setings of our study, including research
questions, data sets, evaluation measures and experimental design.
Section 5 presents the results. Section 6 discusses implications from
the results and the threats to the validity of our study. Section 7
concludes the paper and discusses the future work.
Before beginning, we digress to make two points. Firstly, just
because "DE + SVM" beats deep learning in this application, this
does not mean DE is always the superior method for all other
sofware analytics applications. No learner works best over all
problems [73]– the trick is to try several approaches and select the
arXiv:1703.00133v2  [cs.SE]  24 Jun 2017
ESEC/FSE'17, September 4-8, 2017, Paderborn, Germany
Wei Fu, Tim Menzies
one that works best on the local data. Given the low computational
cost of DE (10 minutes vs 14 hours), DEs are an obvious and low-cost
candidate for exploring such alternatives.
Secondly, to enable other researchers to repeat, improve, or
refute our results, all our scripts and data are freely available on-
line Github1.
2
BACKGROUND AND RELATED WORK
2.1
Why Explore Faster Sofware Analytics?
Tis section argues that avoiding slow methods for sofware ana-
lytics is an open and urgent issue.
Researchers and industrial practitioners now routinely make
extensive use of sofware analytics to discover (e.g.) how long
it will take to integrate the new code [17], where bugs are most
likely to occur [54], who should fx the bug [2], or how long it will
take to develop their code [34, 35, 50]. Large organizations like
Microsof routinely practice data-driven policy development where
organizational policies are learned from an extensive analysis of
large data sets collected from developers [7, 65].
But the more complex the method, the harder it is to apply the
analysis. Fisher et al. [20] characterizes sofware analytics as a
work fow that distills large quantities of low-value data down to
smaller sets of higher value data. Due to the complexities and
computational cost of SE analytics, "the luxuries of interactivity,
direct manipulation, and fast system response are gone" [20]. Tey
characterize modern cloud-based analytics as a throwback to the
1960s-batch processing mainframes where jobs are submited and
then analysts wait, wait, and wait for results with "litle insight into
what is really going on behind the scenes, how long it will take, or
how much it is going to cost" [20]. Fisher et al. [20] document the
issues seen by 16 industrial data scientists, one of whom remarks
"Fast iteration is key, but incompatible with the
jobs are submited and processed in the cloud. It
is frustrating to wait for hours, only to realize you
need a slight tweak to your feature set".
Methods for improving the quality of modern sofware analytics
have made this issue even more serious. Tere has been continuous
development of new feature selection [25] and feature discover-
ing [28] techniques for sofware analytics, with the most recent
ones focused on deep learning methods. Tese are all exciting in-
novations with the potential to dramatically improve the quality of
our sofware analytics tools. Yet these are all CPU/GPU-intensive
methods. For instance:
• Learning control setings for learners can take days to weeks to
years of CPU time [22, 64, 69].
• Lam et al. needed weeks of CPU time to combine deep learning
and text mining to localize buggy fles from bug reports [39].
• Gu et al. spent 240 hours of GPU time to train a deep learning
based method to generate API usage sequences for given natural
language query [24].
Note that the above problem is not solvable by waiting for faster
CPUs/GPUs. We can no longer rely on Moore's Law [51] to double
our computational power every 18 months. Power consumption and
heat dissipation issues efect block further exponential increases to
1htps://github.com/WeiFoo/EasyOverHard
CPU clock frequencies [38]. Cloud computing environments are
extensively monetized so the total fnancial cost of training models
can be prohibitive, particularly for long running tasks. For example,
it would take 15 years of CPU time to learn the tuning parameters
of sofware clone detectors proposed in [69]. Much of that CPU
time can be saved if there is a faster way.
2.2
What is Deep Learning?
Deep learning is a branch of machine learning built on multiple lay-
ers of neural networks that atempt to model high level abstractions
in data. According to LeCun et al. [42], deep learning methods are
representation-learning methods with multiple levels of represen-
tation, obtained by composing simple but non-linear modules that
each transforms the representation at one level (starting with the
raw input) into a representation at a higher, slightly more abstract
level. Compared to the conventional machine learning algorithms,
deep learning methods are very good at exploring high-dimensional
data.
By utilizing extensive computational power, deep learning has
been proven to be a very powerful method by researchers in many
felds [42], like computer vision and natural language process-
ing [4, 37, 47, 60, 63]. In 2012, Convolution neural networks method
won the ImageNet competition [37], which achieves half of the error
rates of the best competing approaches. Afer that, CNN became the
dominant approach for almost all recognition and detection tasks
in computer vision community. CNNs are designed to process the
data in the form of multiple arrays, e.g., image data. According to
LeCun et al. [42], recent CNN methods are usually a huge network
composed of 10 to 20 layers, hundreds of millions of weights and
billions of connections between units. With advanced hardware
and algorithm parallelization, training such model still need a few
hours [42]. For the tasks that deal with sequential data, like text
and speech, recurrent neural networks (RNNs) have been shown
to work well. RNNs are found to be good at predicting the next
character or word given the context. For example, Graves et al. [23]
proposed to use long short-term memory (LSTM) RNNs to perform
speech recognition, which achieves a test set error of 17.7% on the
benchmark testing data. Sutskever et al. [63] used two multiplelay-
ered LSTM RNNs to translate sentences in English to French.
2.3
Deep Learning in SE
We study deep learning since, recently, it has atracted much at-
tentions from researchers and practitioners in sofware commu-
nity [15, 24, 39, 52, 68, 70, 71, 74, 77]. Tese researchers applied deep
learning techniques to solve various problems, including defect pre-
diction, bug localization, clone code detection, malware detection,
API recommendation, efort estimation and linkable knowledge
prediction.
We fnd that this work can be divided into two categories:
• Treat deep learning as a feature extractor, and then apply other
machine learning algorithms to do further work [15, 39, 68].
• Solve problems directly with deep learning [24, 52, 70, 71, 74, 77].
2.3.1
Deep Learning as Pre-Processor. Lam et al. [39] proposed
an approach to apply deep neural network in combination with
rVSM to automatically locate the potential buggy fles for a given
Easy over Hard: A Case Study on Deep Learning
ESEC/FSE'17, September 4-8, 2017, Paderborn, Germany
bug report. By comparing it to baseline methods (Naive Bayes [32],
learn-to-rank [76], BugLocator [79]), Lam et al. reported, 16.2-46.4%,
8-20.8% and 2.7-20.7% higher top-1 accuracy than baseline methods,
respectively [39]. Te training time for deep neural network was
reported from 70 to 122 minutes for 6 projects on a computer with
32 cores 2.00GHz CPU, 126 GB memory. However, the runtime
information of the baseline methods was not reported.
Wang et al. [68] applied deep belief network to automatically
learn semantic features from token vectors extracted from the stud-
ied sofware program. Afer applying deep belief network to gener-
ate features from sofware code, Naive Bayes, ADTree and Logistic
Regression methods are used to evaluate the efectiveness of fea-
ture generation, which is compared to the same learners using
traditional static code features (e.g. McCabe metrics, Halstead's
efort metrics and CK object-oriented code mertics [13, 26, 31, 45]).
In terms of runtime, Wang et al. only report time for generating
semantics features with deep belief network, which ranged from
8 seconds to 32 seconds [68]. However, the time for training and
tuning deep belief network is missing. Furthermore, to compare
the efectiveness of deep belief network for generating features
with methods that extract traditional static code features in terms
of time cost, it would be favorable to include all the time spent on
feature extraction, including paring source code, token generation
and token mapping for both deep belief network and traditional
methods (i.e., an end-to-end comparison).
Choetkiertikul et al. [15] proposed to apply deep learning tech-
niques to solve efort estimation problems on user story level.
Specifcally, Choetkiertikul et al. [15] proposed to leverage long
short-term memory (LSTM) to learn feature vectors from the title,
description and comments associated with an issue report and af-
ter that, regular machine learning techniques, like CART, Random
Forests, Linear Regression and Case-Based Reasoning are applied
to build the efort estimation models. Experimental results show
that LSTM has a signifcant improvement over the baseline method
bag-of-words. However, no further information regarding runtime
as well as experimental hardware is reported for both methods and
there is no cost of this deep learning method at all.
2.3.2
Deep Learning as a Problem Solver. White et al. [70, 71]
applied recurrent neural networks, a type of deep learning tech-
niques, to address code clone detection and code suggestion. Tey
reported, the average training time for 8 projects were ranging from
34 seconds to 2977 seconds for each epoch on a computer with two
3.3 GHz CPUs and each project required at least 30 epochs [70].
Specifcally, for the JDK project in their experiment, it would take
25 hours on the same computer to train the models before geting
prediction. For the time cost for code suggestions, authors did not
mention any related information [71].
Gu et al. [24] proposed a recurrent neural network (RNN) based
method, DEEPAPI, to generate API usage sequences for a given natu-
ral language query. Compared with the baseline method SWIM [57]
and Lucene + UP-Miner [67], DEEPAPI improved the performance
signifcantly. However, that improvement came at a cost: that
model was trained with a Nivdia K20 GPU for 240 hours [24].
XU [74] utilized neural language model and convolution neural
network (CNN) to learn word-level and document-level features to
predict semantically linkable knowledge units on Stack Overfow.
In terms of performance metrics, like precision, recall and F1-score,
CNN method was evaluated much beter than the baseline method
support vector machine (SVM). However, once again, that perfor-
mance improvement came at a cost: their deep learner required 14
hours to train CNN model on a 2.5GHz PC with 16 GB RAM [74].
Yuan et al. [77] proposed a deep belief network based method
for malware detection on Android apps. By training and testing
the deep learning model with 200 features extracted from static
analysis and dynamic analysis from 500 sampled Android app, they
got 96.5% accuracy for deep learning method and 80% for one
baseline method, SVM [77]. However, they did not report any
runtime comparison between the deep learning method and other
classic machine learning methods.
Mou et al. [52] proposed a tree-based convolutional neural net-
work for programming language processing, in which a convolution
kernel is designed over programs' abstract syntax trees to capture
structural information. Results show that their method achieved
94% accuracy, which is beter than the baseline method RBF SVM
88.2% on program classifcation problem [52]. However, Mou et
al. [52] did not discuss any runtime comparison between the pro-
posed method and baseline methods.
2.3.3
Issues with Deep Learning. In summary, deep learning is
used extensively in sofware engineering community. A common
patern in that research is to:
• Report deep learning's benefts, but not its CPU/GPU cost [15,
52, 71, 77];
• Or simply show the cost, without further analysis [24, 39, 68, 70,
74].
Since deep learning techniques cost large amount of time and com-
putational resources to train its model, one might question whether
the improvements from deep learning is worth the costs. Are there
any simple techniques that achieve similar improvements with less
resource costs? To investigate how simple methods could improve
baseline methods, we select XU [74] study as a case study. Te
reasons are as follows:
• Most deep learning paper's baseline methods in SE are either
not publicly available or too complex to implement [39, 70]. XU
defne their baseline methods precisely enough so others can
confdently reproduce it locally. XU's baseline method is SVM
learner, which is available in many machine learning toolboxes.
• Further, it is not yet common practice for deep learning re-
searchers in SE community to share their implementations and
data [15, 24, 39, 68, 70, 71], where a tiny diference may lead to
a huge diference in the results. Even though XU do not share
their CNN tool, their training and testing data are available on-
line, which can be used for our proposed method. Since the
same training and testing data are used for XU's CNN and our
proposed method, we can compare results of our method to their
CNN results.
• Some studies do not report their runtime and experimental envi-
ronment, which makes it harder for us to systematically compare
our results with theirs in terms of computational costs [15, 52, 71,
77]. XU clearly report their experimental hardware and runtime,
which will be easier for us compare our computational costs to
theirs.
ESEC/FSE'17, September 4-8, 2017, Paderborn, Germany
Wei Fu, Tim Menzies
2.4
Parameter Tuning in SE
In this paper, we use DE as an optimizer to do parameter tuning
for SVM, which achieves results that are competitive with deep
learning. Tis section discusses related work on parameter tuning
in SE community.
Machine learning algorithms are designed to explore the in-
stances to learn the bias. However, most of these algorithms are
controlled by parameters such as:
• Te maximum allowed depth of decision tree built by CART;
• Te number of trees to be built within a Random Forest.
Adjusting these parameters is called hyperparameter optimzia-
tion. It is a well well explored approach in other communities [9, 44].
However, in SE, such parameter optimization is not a common
task (as shown in the following examples).
In the feld of defect prediction, Fu et al. [21] surveyed hundreds
of highly cited sofware engineering paper about defect prediction.
Teir observation is that most sofware engineering researchers did
not acknowledge the impact of tunings (exceptions: [43, 64]) and
use the "of-the-shelf" data miners. For example, Elish et al. [18]
compared support vector machines to other data miners for the
purposes of defect prediction. However, the Elish et al. paper makes
no mention of any SVM tuning study [18]. More details about their
survey refer to [21].
In the feld of topic modeling, Agrawal et al. [1] investigated the
impact of parameter tuning on Latent Dirichlet Allocation (LDA).
LDA is a widely used technique in sofware engineering feld to
fnd related topics within unstructured text, like topic analytics on
Stack Overfow [5] and source code analysis [10]. Agrawal et al.
found that LDA sufers from conclusion instability (diferent input
orderings can lead to very diferent results) that is a result of poor
choice of the LDA control parameters [1]. Yet, in their survey of
LDA use in SE, they found that very few researchers (4 out of 57
papers) explored the benefts of parameter tuning for LDA.
One troubling trend is that, in the few SE papers that perform
tuning, they do so using methods heavily deprecated in the ma-
chine learning community. For example, two SE papers that use
tuning [43, 64], apply a simple grid search to explore the potential
parameter space for optimal tunings (such grid searchers run one
for-loop for each parameter being optimized). However, Bergstra
et al. [9] and Fu et al. [22] argue that random search methods (e.g.
the diferential evolution algorithm used here) are beter than grid
search in terms of efciency and performance.
3
METHOD
3.1
Research Problem
Tis section is an overview of the the task and methods used by
XU. Teir task was to predict relationships between two knowledge
units (questions with answers) on Stack Overfow. Specifcally, XU
divided linkable knowledge unit pairs into 4 diference categories
namely, duplicate, direct link, indirect link and isolated, based on its
relatedness. Te defnition of these four categories are shown in
Table 1 [74]:
In that paper, XU provided the following two methods as base-
lines [74]:
Table 1: Classes of Knowledge Unit Pairs.
Class
Description
Duplicate
Tese two knowledge units are addressing the
same question.
Direct link
One knowledge unit can help to answer the
question in the other knowledge unit.
Indirect link
One knowledge provides similar information to
solve the question in the other knowledge unit,
but not a direct answer.
Isolated
Tese two knowledge units discuss unrelated
questions.
• TF-IDF + SVM: a multi-class SVM classifer with 36 textual
features generated based on the TF and IDF values of the words
in a pair of knowledge units.
• Word Embedding + SVM: a multi-class SVM classifer with word
embedding generated by the word2vec model [47].
Both of these two baseline methods are compared against their
proposed method, Word Embedding + CNN.
In this study, we select Word Embedding + SVM as the baseline
because it uses word embedding as the input, which is the same as
the Word Embedding + CNN method by XU.
3.2
Learners and Teir Parameters
SVM has been proven to be a very successful method to solve text
classifcation problem. A SVM seeks to minimize misclassifcation
errors by selecting a boundary or hyperplane that leaves the max-
imum margin between positive and negative classes (where the
margin is defned as the sum of the distances of the hyperplane
from the closest point of the two classes [29]).
Like most machine learning algorithms, there are some parame-
ters associated with SVM to control how it learns. In XU's experi-
ment, they used a radial-bias function (RBF) for their SVM kernel
and set γ to 1/k, where k is 36 for TF-IDF + SVM method and
200 for Word Embedding + SVM method. For other parameters,
XU mentioned that grid search was applied to optimize the SVM
parameters, but no further information was disclosed.
For our work, we used the SVM module from Scikit-learn [55], a
Python package for machine learning, where the parameters shown
in Table. 2 are selected for tuning. Parameter C is to set the amount
of regularization, which controls the tradeof between the errors
on training data and the model complexity. A small value for C
will generate a simple model with more training errors, while a
large value will lead to a complicated model with fewer errors.
Kernel is to introduce diferent nonlinearities into the SVM model
by applying kernel functions on the input data. Gamma defnes
how far the infuence of a single training example reaches, with
low values meaning 'far' and high values meaning 'close'. coef0 is
an independent parameter used in sigmod and polynomial kernel
function.
As to why we used the "Tuning Range" shown in Table 2, and not
some other ranges, we note that (a) those ranges include the defaults
and also XU's values; (b) the results presented below show that by
exploring those ranges, we achieved large gains in the performance
of our baseline method. Tis is not to say that larger tuning ranges
Easy over Hard: A Case Study on Deep Learning
ESEC/FSE'17, September 4-8, 2017, Paderborn, Germany
Table 2: List of Parameters Tuned by Tis Paper.
Parameters
Default
Xue et al.
Tuning Range
Description
C
1.0
unknown
[1, 50]
Penalty parameter C of the error term.
kernel
'rbf'
'rbf'
['liner', 'poly', 'rbf', 'sigmoid']
Specify the kernel type to be used in the algorithms.
gamma
1/n features
1/200
[0, 1]
Kernel coefcient for 'rbf', 'poly' and 'sigmoid'.
coef0
0
unknown
[0, 1]
Independent term in kernel function. It is only used in 'poly' and 'sigmoid'.
might not result in greater improvements. However, for the goals
of this paper (to show that tuning baseline method does mater),
exploring just these ranges shown in Table 2 will sufce.
3.3
Learning Word Embedding
Learning word embeddings refers to fnd vector representations
of words such that the similarities between words can be captured
by cosine similarity of corresponding vector representations. It is
been shown that the words with similar semantic and syntactic are
found closed to each other in the embedding space [47].
Several methods have been proposed to generate word embed-
dings, like skip-gram [47], GloVe [56] and PCA on the word co-
occurrence matrix [41]. To replicate XU work, we used the contin-
uous skip-gram model (word2vec), which is a unsupervised word
representation learning method based on neural networks and also
used by XU [74].
Te skip-gram model learns vector representations of words by
predicting the surrounding words in a context window. Given a sen-
tence of words W = w1,w2,…,wn, the objective of skip-gram model
is to maximize the the average log probability of the surrounding
words:
1
n
n
�
i=1
�
−c ≤j ≤c,j�0
loдp(wi+j |wi)
where c is the context window size and wi+j and wi represent
surrounding words and center word, respectively. Te probability
of p(wi+j |wi) is computed according to the sofmax function:
p(wO |wI ) =
exp(vTwOvwI )
�|W |
w=1 exp(vTwvwI )
where vwI and vwO are the vector representations of the input and
output vectors of w, respectively. �|W |
w=1 exp(vTwvwI ) normalizes
the inner product results across all the words. To improve the
computation efciency, Mikolove et al. [47] proposed hierachical
sofmax and negative sampling techniques. More details can be
found in Mikolove et al.'s study [47].
Skip-gram's parameters control how that algorithm learns word
embeddings. Tose parameters include window size and dimen-
sionality of embedding space, etc. Zucoon et al. [80] found that
embedding dimensionality and context window size have no con-
sistent impact on retrieval model performance. However, Yang et
al. [75] showed that large context window and dimension sizes
are preferable to improve the performance when using CNN to
solve classifcation tasks for Twiter. Since this work is to compare
performance of tuning SVM with CNN, where skip-gram model
is used to generate word vector representations for both of these
methods, tuning parameter of skip-gram model is beyond the scope
of this paper (but we will explore it in future work).
1. Given a model (e.g., SVM) with n decisions (e.g., n = 4), TUNER calls
SAMPLE N = 10 ∗ n times. Each call generates one member of the
population popi∈N .
2. TUNER scores each popi according to various objective scores o. In
the case of our tuning SVM, the objective o is to maximize F1-score
3. TUNER tries to each replace popi with a mutant m built using Storn's
diferential evolution method [62]. DE extrapolates between three other
members of population a, b, c. At probability p1, for each decision
ak ∈ a, then mk = ak ∨ (p1 < rand() ∧ (bk ∨ ck)).
4. Each mutant m is assessed by calling EVALUATE(model, prior=m);
i.e. by seeing what can be achieved within a goal afer frst assuming
that prior = m.
5. To test if the mutant m is preferred to popi, TUNER simply compare
SCORE(m) with SCORE(popi). In case of our tuning SVM, the one with
higher score will be kept.
6. TUNER repeatedly loops over the population, trying to replace items
with mutants, until new beter mutants stop being found.
7. Return the best one in the population as the optimal tunings.
Figure 1: Procedure TUNER: strives to fnd "good" tunings
which maximizes the objective score of the model on train-
ing and tuning data. TUNER is based on Storn's diferential
evolution optimizer [62].
To train our word2vec model, 100, 000 knowledge units tagged
with "java" from Stack Overfow posts table (include titles, ques-
tions and answers) are randomly selected as a word corpus2. Afer
applying proper data processing techniques proposed by XU, like
remove the unnecessary HTML tags and keep short code snippets
in code tag, then ft the corpus into gensim word2vec module [58],
which is a python wrapper over original word2vec package.
When converting knowledge units into vector representations,
for each word wi in the post processed knowledge unit (including
title, question and answers), we query the trained word2vec model
to get the corresponding word vector representation vi. Ten the
whole knowledge unit with s words is converted to vector repre-
sentation by element-wise addition, Uv = vi ⊕ v2 ⊕ ... ⊕ vs. Tis
vector representation is used as the input data to SVM.
3.4
Tuning Algorithm
A tuning algorithm is an optimizer that drives the learner to explore
the optimal parameter in a given searching space. According to our
literature review, there are several searching algorithms used in
SE community:simulated annealing [19, 46]; various genetic algo-
rithms [3, 27, 30] augmented by techniques such as diferential evo-
lution [1, 12, 21, 22, 62], tabu search and scater search [6, 16, 49]; par-
ticle swarm optimization [72]; numerous decomposition approaches
2Without further explanation, all the experiment setings, including learner algorithms,
training/testing data split, etc, strictly follow XU's work.
ESEC/FSE'17, September 4-8, 2017, Paderborn, Germany
Wei Fu, Tim Menzies
that use heuristics to decompose the total space into small prob-
lems, then apply a response surface methods [36]; NSGA-II [78]and
NSGA-III [48].
Of all the mentioned algorithms, the simplest are simulated
annealing (SA) and diferential evolution (DE), each of which can
be coded in less than a page of some high-level scripting language.
Our reading of the current literature is that there are more advocates
for diferential evolution than SA. For example, Vesterstrom and
Tomsen [66] found DE to be competitive with particle swarm
optimization and other GAs. DEs have already been applied before
for parameter tuning in SE community to do parameter tuning (e.g.
see [1, 14, 21, 22, 53]) . Terefore, in this work, we adopt DE as our
tuning algorithm and the main steps in DE is described in Figure 1.
4
EXPERIMENTAL SETUP
4.1
Research Qestions
To systematically investigate whether tuning can improve the per-
formance of baseline methods compared with deep learning method,
we set the following three research questions:
• RQ1: Can we reproduce XU's baseline results (Word Embedding +
SVM)?
• RQ2: Can DE tune a standard learner such that it outperforms
XU's deep learning method?
• RQ3: Is tuning SVM with DE faster than XU's deep learning
method?
RQ1 is to investigate whether our implementation of Word Em-
bedding + SVM method has the similar performance with XU's
baseline, which makes sure that our following analysis can be gen-
eralized to XU's conclusion. RQ2 and RQ3 lead us to investigate
whether tuning SVM comparable with XU's deep learning from
both performance and cost aspects.
4.2
Dataset and Experimental Design
Our experimental data comes from Stack Overfow data dump of
September 20163, where the posts table includes all the questions
and answers posted on Stack Overfow up to date and the postlinks
table describes the relationships between posts, e.g., duplicate and
linked. As mentioned in Section 3.1, we have four diferent types
of relationships in knowledge unit pairs. Terefore, linked type is
further divided into indirectly linked and directly linked. Overall,
four diferent types of data are generated according the following
rules [74]:
• Randomly select a pair of posts from the postlinks table, if the
value in PostLinkTypeId feld for this pair of posts is 3, then this
pair of posts is duplicate posts. Otherwise they're directly linked
posts.
• Randomly select a pair of posts from the posts table, if this pair
of posts is linkable from each other according to postlinks table
and the distance between them are greater than 2 (which means
they are not duplicate or directly linked posts), then this pair of
posts is indirectly linked. If they're not linkable, then this pair
of posts is isolated.
3htps://archive.org/details/stackexchange
Word2Vec
Word
Embeddings
Lookup
Testing	KU	
vectors
Predict
Results
Training	KU	pairs
New	Training	KU	vectors
Tuning
KU	vectors
Lookup
SVM
100,000	KU	texts
Train
Evaluate
Train
SVM
Parameters
DE
Best	Tunings
Train
Train	Word2Vec
Train	Learner
Test	Learner
Parameter	Tuning
Testing	KU	pairs
Figure 2: Te Overall Workfow of Building Knowledge
Units Predictor with Tuned SVM
In this work, we use the same training and testing knowledge
unit pairs as XU [74]4, where 6,400 pairs of knowledge units for
training and 1,600 pairs for testing. And each type of linked knowl-
edge units accounts for 1/4 in both training and testing data. Te
reasons that we used the same training and testing data as XU are:
• It is to ensure that performance of our baseline method is as
closed to XU's as possible.
• Since deep learning method is way complicated compared to
SVM and a litle diference in implementations might lead to
diferent results. To fairly compare with XU's result, we can use
the performance scores of CNN method from XU's study [74]
without any implementation bias introduced.
For training word2vec model, we randomly select 100,000 knowl-
edge units (title, question body and all the answers) from posts table
that are related to "java". Afer that, all the training/tuning/testing
knowledge units used in this paper are converted into word embed-
ding representations by looking up each word in wrod2vec model
as described in Section 3.3.
As seen in Figure 2, instead of using all the 6,400 knowledge units
as training data, we split the original training data into new training
data and tuning data, which are used during parameter tuning
procedure for training SVM and evaluating candidate parameters
ofered by DE. Aferwards, the new training data is again fted
into the SVM with the optimal parameters found by DE and fnally
the performance of the tuned SVM will be evaluated on the testing
data.
To reduce the potential variance caused by how the original train-
ing data is divided, 10-fold cross-validation is performed. Specifcally,
each time one fold with 640 knowledge units pairs is used as the
tuning data, and the remaining folds with 5760 knowledge units
are used as the new training data, then the output SVM model will
be evaluated on the testing data. Terefore, all the performance
scores reported below are averaged values over 10 runs.
In this study, we use Wilcoxon single ranked test to statistically
compare the diferences between tuned SVM and untuned SVM.
Specifcally, the Benjamini-Hochberg (BH) adjusted p-value is used
to test whether a diference is statistically signifcant at the level of
0.05 [8]. To measure the efect size of performance scores between
4htps://github.com/XBWer/ASEDataset
Easy over Hard: A Case Study on Deep Learning
ESEC/FSE'17, September 4-8, 2017, Paderborn, Germany
tuned SVM and untuned SVM, we compute Clif's δ that is a non-
parametric efect size measure [59]. As Romano et al. suggested,
we evaluate the magnitude of the efect size as follows: negligible
(|δ| < 0.147 ), small (0.147 < |δ| < 0.33), medium (0.33 < |δ| <
0.474 ), and large (0.474 ≤ |δ|) [59].
4.3
Evaluation Metrics
When evaluating the performance of tuning SVM on the multi-
class linkable knowledge units prediction problem, consistent with
XU [74], we use accuracy, precision, recall and F1-score as the
evaluation metrics.
Table 3: Confusion Matrix.
Classifed as
C1
C2
C3
C4
Actual
C1
c11
c12
c13
c14
C2
c21
c22
c23
c24
C3
c31
c32
c33
c34
C4
c41
c42
c43
c44
Given a multi-classifcation problem with true labels C1, C2, C3
and C4, we can generate a confusion matrix like Table 3, where the
value of cii represents the number of instances that are correctly
classifed by the learner for class Ci.
Accuracy of the learner is defned as the number of correctly
classifed knowledge units over the total number of knowledge
units, i.e.,
accuracy =
�
i cii
�
i
�
j cij
where �
i
�
j cij is the total number of knowledge units. For a given
type of knowledge units, Cj, the precision is defned as probability
of knowledge units pairs correctly classifed as Cj over the number
of knowledge unit pairs classifed as Cj and recall is defned as the
percentage of all Cj knowledge unit pairs correctly classifed. F1-
score is the harmonic mean of recall and precision. Mathematically,
precision, recall and F1-score of the learner for class Cj can be
denoted as follows:
precj
= precisionj =
cjj
�
i cij
pdj
= recallj =
cjj
�
i cji
F1j
= 2 ∗ pdj ∗ precj/(pdj + precj)
Where �
i cij is the predicted number of knowledge units in class
Cj and �
i cji is the actual number of knowledge units in class Cj.
Recall from Algorithm 1 that we call diferential evolution once
for each optimization goal. Generally, this goal depends on which
metric is most important for the business case. In this work, we
use F1 to score the candidate parameters because it controls the
trade-of between precision and recall, which is also consistent with
XU [74] and is also widely used in sofware engineering community
to evaluate classifcation results [21, 33, 46, 68].
5
RESULTS
In this section, we present our experimental results. To answer
research questions raised in Section 4.1, we conducted two experi-
ments:
Figure 3: Score Delta between Our SVM with XU's SVM
in [74] in Terms of Precision, Recall and F1-score. Positive
Values Mean Our SVM is Better than XU's SVM in Terms of
Diferent Measures; Otherwise, XU's SVM is better.
• Compare performance of Word Embedding + SVM method in
XU [74] and our implementation;
• Compare performance of our tuning SVM with DE method with
XU's CNN deep learning method.
Since we used the same training and testing data sets provided by
XU [74] and conducted our experiment in the same procedure and
evaluated methods using the performance measures, we simply
used the results reported in the work by XU [74] for the perfor-
mance comparison.
RQ1: Can we reproduce XU's baseline results (Word Em-
bedding + SVM)?
Tis frst question is important to our work since, without the
original tool released by XU, we need to insure that our reimple-
mentation of their baseline method (WordEmbedding + SVM) has a
similar performance to their work. Accordingly, we carefully follow
XU's procedure [74]. We use the SVM learner from scikit-learn
with the seting γ =
1
200 and kernel ="rbf", which are used by XU.
Afer that, the same training and testing knowledge unit pairs are
applied to SVM.
Table 4: Comparison of Our Baseline Method with XU's. Te
Best Scores are Marked in Bold.
Metrics
Methods
Duplicate
Direct
Link
Indirect
Link
Isolated
Overall
Precision
Our SVM
0.724
0.514
0.779
0.601
0.655
XU's SVM
0.611
0.560
0.787
0.676
0.659
Recall
Our SVM
0.525
0.492
0.970
0.645
0.658
XU's SVM
0.725
0.433
0.980
0.538
0.669
F1-score
Our SVM
0.609
0.503
0.864
0.622
0.650
XU's SVM
0.663
0.488
0.873
0.600
0.656
Accuracy
Our SVM
0.525
0.493
0.970
0.645
0.658
XU's SVM
-
-
-
-
0.669
Table 4 and Figure 3 show the performance scores and corre-
sponding score delta between our implementation of WordEmbed-
ding + SVM with XU's in terms of accuracy 5, precision, recall and
5XU just report overall accuracy, not for each class, hence it is missing in this table.
ESEC/FSE'17, September 4-8, 2017, Paderborn, Germany
Wei Fu, Tim Menzies
Figure 4:
Score Delta between Tuned SVM and CNN
method [74] in Terms of Precision, Recall and F1-score. Pos-
itive Values Mean Tuned SVM is Better than CNN in Terms
of Diferent Measures; Otherwise, CNN is better.
F1-score. As we can see, when predicting these four diferent types
of relatedness between knowledge unit pairs, our Word Embedding
+ SVM method has very similar performance scores to the baseline
method reported by XU in [74], with the maximum diference less
than 0.2. Except for Duplicate class, where our baseline has a
higher precision (i.e., 0.724 v.s. 0.611) but a lower recall (i.e., 0.525
v.s.0.725).
Figure 3 presents the same results in a graphical format. Any
bar above zero means that our implementation has a beter perfor-
mance score than XU's on predicting that specifc knowledge unit
relatedness class. As we can see, most of the diferences ( 8
12) are
within 0.05 and the score delta of overall performance shows that
our implementation is a litle worse than XU's implementation. For
this chart we conclude that:
Overall, our reimplementation of WordEmbedding + SVM
has very similar performance in all the evaluated metrics
compared to the baseline method reported in XU's study [74].
Te signifcance of this conclusion is that, moving forward, we are
confdent that we can use our reimplementation of WordEmbed-
ding+SVM as a valid surrogate for the baseline method of XU.
RQ2: Can DE tune a standard learner such that it outper-
forms XU's deep learning method?
To answer this question, we run the workfow of Figure 2, where
DE is applied to fnd the optimal parameters of SVM based on the
training and tuning data. Te optimal tunings are then applied on
the SVM model and the built learner is evaluated on testing data.
Note that, in this study, since we mainly focus on precision, recall
and F1-score measures where F1-score is the harmonic mean of
precision and recall, we use F1-score as the tuning goal for DE. In
other words, when tuning parameters, DE expects to fnd a pair of
candidate parameters that maximize F1-score.
Table 5 presents the performance scores of XU's baseline, XU's
CNN method and Tuned SVM for all metrics. Te highest score
for each relatedness class is marked in bold. Note that: Without
tuning, XU's CNN method outperforms the baseline SVM in 10
12
Figure 5: Score Delta between Tuned SVM and XU's Baseline
SVM in Terms of Precision, Recall and F1-score. Positive Val-
ues Mean Tuned SVM is Better than XU's SVM in Terms of
Diferent Measures; Otherwise, XU's SVM is better.
Table 5: Comparison of Tuned SVM with XU's CNN Method.
Te Best Scores are Marked in Bold.
Metrics
Methods
Duplicate
Direct
Link
Indirect
Link
Isolated
Overall
Precision
XU's SVM
0.611
0.560
0.787
0.676
0.658
XU's CNN
0.898
0.758
0.840
0.890
0.847
Tuned SVM
0.885
0.851
0.944
0.903
0.896
Recall
XU's SVM
0.725
0.433
0.980
0.538
0.669
XU's CNN
0.898
0.903
0.773
0.793
0.842
Tuned SVM
0.860
0.828
0.995
0.905
0.897
F1-score
XU's SVM
0.663
0.488
0.873
0.600
0.656
XU's CNN
0.898
0.824
0.805
0.849
0.841
Tuned SVM
0.878
0.841
0.969
0.909
0.899
evaluation metrics across all four classes. Te largest performance
improvement is 0.47 for recall on Direct Link class. Note that this
result is consistent with XU's conclusion that their CNN method
is superior to standard SVM. Afer tuning SVM, the deep learning
method has no such advantage. Specifcally, CNN has advantage
over tuned SVM in 4
12 evaluation metrics across all four classes.
Even when CNN performs beter that our tuning SVM method, the
largest diference is 0.065 for Recall on Direct Link class, which is
less than 0.1.
Figure 4 presents the same results in a graphical format. Any bar
above zero indicates that tuned SVM has a beter performance score
than CNN. In this fgure: CNN has a slightly beter performance
on Duplicate class for precision, recall and F1-score and a higher
recall on Direct link class. Across all of Figure 4, in 8
12 evaluation
scores, Tuned SVM has beter performance scores than CNN, with
the largest delta of 0.222.
Figure 5 compares the performance delta of tuned SVM with
XU's untuned SVM. We note that DE-based parameter tuning never
degrades SVM's performance (since there are no negative values
in that chart). Tuning dramatically improves scores on predicting
some classes of KU relatedness. For example, the recall of pre-
dicting Direct link is increased from 0.433 to 0.903, which is 108%
improvement over XU's untuned SVM (To be fair for XU, it is still
Easy over Hard: A Case Study on Deep Learning
ESEC/FSE'17, September 4-8, 2017, Paderborn, Germany
Figure 6: Score Delta between Tuned SVM and Our Untuned
SVM in Terms of Precision, Recall and F1-score. Positive Val-
ues Mean Tuned SVM is Better than Our Untuned SVM in
Terms of Diferent Measures; Otherwise, Our SVM is Better.
84% improvement over our untuned SVM). At the same time, the
corresponding precision and F1 scores of predicting Direct Link
are increased from 0.560 to 0.851 and 0.488 to 0.841, which are 52%
and 72% improvement over XU's original report[74], respectively.
A similar patern can also be observed in Isolated class. On average,
tuning helps improve the performance of XU's SVM by 0.238, 0.228
and 0.227 in terms of precision, recall and F1-score for all four KU
relatedness classes. Figure 6 compares the tuned SVM with our un-
tuned SVM. We note that we get the similar paterns that observed
in Figure 5. All the bars are above zero, etc.
Based on the performance scores in Table 5 and score delta in
Figure 4, Figure 5 and Figure 6, we can see that:
• Parameter tuning can dramatically improve the performance of
Word Embedding + SVM (the baseline method) for the multi-
class KU relatedness prediction task;
• With the optimal tunings, the traditional machine learning
method, SVM, if not beter, is at least comparable with deep
learning methods (CNN).
When discussing this result with colleagues, we are sometimes
asked for a statistical analysis that confrms the above fnding.
However, due the lack of evaluation score distributions of the CNN
method in [74], we cannot compare their single value with our
results from 10 repeated runs. However, according to Wilcoxon
singed rank test over 10 runs results, tuned SVM performs sta-
tistically beter than our untuned SVM in terms of all evaluation
measures on all four classes (p < 0.05). According to Clif δ values,
the magnitude of diference between tuned SVM and our untuned
SVM is not trivial (|δ| > 0.147) for all evaluation measures.
Overall, the experimental results and our analysis indicate that:
In the evaluation conducted here, the deep learning method,
CNN, does not have any performance advantage over our
tuning approach.
RQ3: Is tuning SVM with DE faster than XU's deep learn-
ing method?
When comparing the runtime of two learning methods, it obvi-
ously should be conducted under the same hardware setings. Since
we adopt the CNN evaluation scores from [74], we can not run on
our tuning SVM experiment under the exactly same system set-
tings. To allow readers to have a objective comparison, we provide
the experimental environment as shown in Table 6. To obtain the
runtime of tuning SVM, we recorded the start time and end time of
the program execution, including parameter tuning, training model
and testing model.
Table 6: Comparison of Experimental Environment
Methods
OS
CPU
RAM
Tuning SVM
MacOS 10.12
Intel Core i5 2.7 GHz
8 GB
CNN
Windows 7
Intel Core i7 2.5 GHz
16 GB
According to XU, it took 14 hours to train their CNN model into
a low loss convergence (< e−3) [74]. Our work, on the other hand
only takes 10 minutes to run SVM with parameter tuning by DE
on a similar environment. Tat is, the simple parameter tuning
method on SVM is 84X faster than XU's deep learning method.
Compared to CNN method, tuning SVM is about 84X faster
in terms of model building.
Te signifcance of this fnding is that, in this case study, CNN
was neither beter in performance scores (see RQ2) nor runtimes.
CNN's extra runtimes are a particular concern since (a) they are
very long; and (b) these would be incurred anytime researchers
wants to update the CNN model with new data or wanted to validate
the XU result.
6
DISCUSSION
6.1
Why DE+SVM works?
Parameter tuning matters. As mentioned in Section 2.4, the de-
fault parameter values set by the algorithm designers could generate
a good performance on average but may not guarantee the best
performance for the local data [9, 21]. Given that, it is most strange
to report that most SE researchers ignore the impacts of parame-
ter tuning when they utilize various machine learning methods to
conduct sofware analytic (evidence: see our reviews in [1, 21, 22]).
Te conclusion of this work must be to stress the importance of this
kind of tuning, using local data, for any future sofware analytics
study.
Better explore the searching space. It turns out that one
exception to our statement that "most researchers do not tune" is
the XU study. In that work, they unsuccessfully perform parameter
tuning, but with with grid search. In such a grid search, for N
parameters to be tuned, N for loops are created to run over a range
of setings for each parameter. While a widely used method, it
is ofen deprecated. For example, Bergstra et al.[9] note that grid
search jumps through diferent parameter setings between some
min and max values of pre-defned tuning range. Tey warn that
such jumps may actually skip over the critical tuning values. On
the other hand, DE tuning values are adjusted based on beter
candidates from previous generations. Hence DE is more likely
than grid search to "fll in the gaps" between the initialized values.
ESEC/FSE'17, September 4-8, 2017, Paderborn, Germany
Wei Fu, Tim Menzies
Tat said, although DE +SVM works in this study, it does not
mean DE is the best parameter tuner for all SE tasks. We encourage
more researchers to explore faster and more efective parameter
tuners in this direction.
6.2
Implication
Beyond the specifcs of this case study, what general principles can
we take from the above work?
Understand the task. One reason to try diferent tools for the
same task is to beter understand the task. Te more we understand
a task, the beter we can match tools to that task. Tools that are
poorly matched to task are usually complex and/or slow to execute.
In the case study of this paper, we would say that
• Deep learning is a poor match to the task of predicting whether
two questions posted on Stack Overfow are semantically link-
able since it is so slow;
• Diferential evolution tuning SVM is a much beter match since
it is so fast and obtain competitive performance.
Tat said, it is important to stress that the point of this study is
not to deprecate deep learning. Tere are many scenarios were
we believe deep learning would be a natural choice (e.g. when
analyzing complex speech or visual data). In SE, it is still an open
research question that in which scenario deep learning is the best
choice. Results from this paper show that, at least for classifcation
tasks like knowledge unit relatedness classifcation on Stack Over-
fow, deep learning does not have much advantage over well tuned
conventional machine learning methods. However, as we beter
understand SE tasks, deep learning could be used to address more
SE problems, which require more advanced artifcial intelligence.
Treat resource constraints as design challenges. As a gen-
eral engineering principle, we think it insightful to consider the
resource cost of a tool before applying it. It turns out that this
is a design patern used in contemporary industry. According to
Calero and Patini [11], many current commercial redesigns are
motivated (at least in part) by arguments based on sustainability
(i.e. using fewer resources to achieve results). In fact, they say that
managers used sustainability-based redesigns to motivate extensive
cost-cuting opportunities.
6.3
Treads to Validity
Treats to internal validity concern the consistency of the results
obtained from the result. In our study, to investigate how tuning
can improve the performance of baseline methods and how well
it perform compared with deep learning method. We select XU's
Word Embedding + SVM baseline method as a case study. Since
the original implementation of Word Embedding + SVM (baseline
2 method in [74]) is not publicly available, we have to reimplement
our version of Word Embedding + SVM as the baseline method
in this study. As shown in RQ1, our implementation has quite
similar results to XU's on the same data sets. Hence, we believe
that our implementation refect the original baseline method in
Xu's study [74].
Treats to external validity represent if the results are of rele-
vance for other cases, or the ability to generalize the observations in
a study. In this study, we compare our tuning baseline method with
deep learning method, CNN, in terms of precision, recall, F1-score
and accuracy. Te experimental results are quite consistent for
this knowledge units relatedness prediction task. Nonetheless, we
do not claim that our fndings can be generalized to all sofware
analytics tasks. However, those other sofware analytics tasks ofen
apply deep learning methods on classifcation tasks [15, 68] and so
it is quite possible that the methods of this paper (i.e., DE-based
parameter tuning) would be widely applicable, elsewhere.
7
CONCLUSION
In this paper, we perform a comparative study to investigate how
tuning can improve the baseline method compared with state-of-
the-art deep learning method for predicting knowledge units relat-
edness on Stack Overfow. Our experimental results show that:
• Tuning improves the performance of baseline methods. At least
for Word Embedding + SVM (baseline in [74]) method, if not
beter, it performs as well as the proposed CNN method in [74].
• Te baseline method with parameter tuning runs much faster
than complicated deep learning. In this study, tuning SVM runs
84X faster than CNN method.
8
ADDENDUM
As this paper was going to going to press we learned of a new
deep learning methods that, according to its creators, runs 20 times
faster than standard deep learning [61]. Note that in that paper, the
authors say their faster method does not produce beter results– in
fact, their method generated solutions that were a small fraction
worse than "classic" deep learning. Hence, that paper does not
invalidate our result since (a) our DE-based method sometimes
produced beter results than classic deep learning and (b) our DE
runs 84 times faster (i.e. much faster runtimes than those reported
in [61]).
Tat said, this new fast deep learner deserves our close atention
since, using it, we conjecture that our DE tools could solve an open
problem in the deep learning community; i.e. how to fnd the best
confgurations inside a deep learner faster.
Based on the results of this study, we recommend that before
applying deep learning method on SE tasks, implement simpler
techniques. Tese simpler methods could be used, at the very least,
for comparisons against a baseline. In this particular case of deep
learning vs DE, the extra computational efort is so very minor (10
minutes on top of 14 hours), that such a "try-with-simpler" should
be standard practice.
As to the future work, we will explore more simple techniques
to solve SE tasks and also investigate how deep learning techniques
could be applied efectively in sofware engineering feld.
ACKNOWLEDGEMENTS
Te work is partially funded by an NSF award #1302169.
REFERENCES
[1] Amritanshu Agrawal, Wei Fu, and Tim Menzies. 2016. What is wrong with
topic modeling?(and how to fx it using search-based se).
arXiv preprint
arXiv:1608.08176 (2016).
[2] John Anvik, Lyndon Hiew, and Gail C Murphy. 2006. Who should fx this bug?.
In Proceedings of the 28th International Conference on Sofware Engineering. ACM,
361–370.
Easy over Hard: A Case Study on Deep Learning
ESEC/FSE'17, September 4-8, 2017, Paderborn, Germany
[3] Andrea Arcuri and Gordon Fraser. 2011. On parameter tuning in search based
sofware engineering. In International Symposium on Search Based Sofware
Engineering. Springer, 33–47.
[4] Itamar Arel, Derek C Rose, and Tomas P Karnowski. 2010. Research Frontier:
Deep Machine Learning–a New Frontier in Artifcial Intelligence Research. IEEE
Computational Intelligence Magazine 5, 4 (2010), 13–18.
[5] Anton Barua, Stephen W Tomas, and Ahmed E Hassan. 2014. What are devel-
opers talking about? an analysis of topics and trends in stack overfow. Empirical
Sofware Engineering 19, 3 (2014), 619–654.
[6] Ricardo P Beausoleil. 2006. "MOSS" multiobjective scater search applied to non-
linear multiple criteria optimization. European Journal of Operational Research
169, 2 (2006), 426–449.
[7] Andrew Begel and Tomas Zimmermann. 2014. Analyze this! 145 questions for
data scientists in sofware engineering. In Proceedings of the 36th International
Conference on Sofware Engineering. ACM, 12–23.
[8] Yoav Benjamini and Yosef Hochberg. 1995. Controlling the false discovery rate: a
practical and powerful approach to multiple testing. Journal of the royal statistical
society. Series B (Methodological) (1995), 289–300.
[9] James Bergstra and Yoshua Bengio. 2012. Random search for hyper-parameter
optimization. Journal of Machine Learning Research 13, Feb (2012), 281–305.
[10] David Binkley, Daniel Heinz, Dawn Lawrie, and Justin Overfelt. 2014. Under-
standing LDA in source code analysis. In Proceedings of the 22nd International
Conference on Program Comprehension. ACM, 26–36.
[11] Coral Calero and Mario Piatini. 2015. Green in Sofware Engineering. (2015).
[12] Jos´e M Chaves-Gonz´alez and Miguel A P´erez-Toledano. 2015. Diferential evolu-
tion with Pareto tournament for the multi-objective next release problem. Appl.
Math. Comput. 252 (2015), 1–13.
[13] Shyam R Chidamber and Chris F Kemerer. 1994. A metrics suite for object
oriented design. IEEE Transactions on Sofware Engineering 20, 6 (1994), 476–493.
[14] Ibtissem Chiha, J Ghabi, and Noureddine Liouane. 2012. Tuning PID controller
with multi-objective diferential evolution. In 2012 5th International Symposium
on Communications, Control and Signal Processing. IEEE, 1–4.
[15] Morakot Choetkiertikul, Hoa Khanh Dam, Truyen Tran, Trang Pham, Aditya
Ghose, and Tim Menzies. 2016. A deep learning model for estimating story
points. arXiv preprint arXiv:1609.00489 (2016).
[16] Anna Corazza, Sergio Di Martino, Filomena Ferrucci, Carmine Gravino, Federica
Sarro, and Emilia Mendes. 2013. Using tabu search to confgure support vector
regression for efort estimation. Empirical Sofware Engineering 18, 3 (2013),
506–546.
[17] Jacek Czerwonka, Rajiv Das, Nachiappan Nagappan, Alex Tarvo, and Alex
Teterev. 2011. Crane: Failure prediction, change analysis and test prioritization in
practice–experiences from windows. In Proceedings of the 4th IEEE International
Conference on Sofware Testing, Verifcation and Validation. IEEE, 357–366.
[18] Karim O Elish and Mahmoud O Elish. 2008. Predicting defect-prone sofware
modules using support vector machines. Journal of Systems and Sofware 81, 5
(2008), 649–660.
[19] Martin S Feather and Tim Menzies. 2002. Converging on the optimal atainment
of requirements. In Proceedings of the 10th Anniversary IEEE Joint International
Conference on Requirements Engineering. IEEE, 263–270.
[20] Danyel Fisher, Rob DeLine, Mary Czerwinski, and Steven Drucker. 2012. Interac-
tions with big data analytics. interactions 19, 3 (2012), 50–59.
[21] Wei Fu, Tim Menzies, and Xipeng Shen. 2016. Tuning for sofware analytics: Is
it really necessary? Information and Sofware Technology 76 (2016), 135–146.
[22] Wei Fu, Vivek Nair, and Tim Menzies. 2016. Why is diferential evolution beter
than grid search for tuning defect predictors? arXiv preprint arXiv:1609.02613
(2016).
[23] Alex Graves, Abdel-rahman Mohamed, and Geofrey Hinton. 2013. Speech
recognition with deep recurrent neural networks. In 2013 IEEE International
Conference on Acoustics, Speech and Signal Processing. IEEE, 6645–6649.
[24] Xiaodong Gu, Hongyu Zhang, Dongmei Zhang, and Sunghun Kim. 2016. Deep
API learning. In Proceedings of the 2016 24th ACM SIGSOFT International Sympo-
sium on Foundations of Sofware Engineering. ACM, 631–642.
[25] Mark A Hall and Geofrey Holmes. 2003. Benchmarking atribute selection
techniques for discrete class data mining. IEEE Transactions on Knowledge and
Data engineering 15, 6 (2003), 1437–1447.
[26] Maurice Howard Halstead. 1977. Elements of sofware science. Vol. 7. Elsevier
New York.
[27] Mark Harman. 2007. Te current state and future of search based sofware
engineering. In 2007 Future of Sofware Engineering. IEEE Computer Society,
342–357.
[28] Tian Jiang, Lin Tan, and Sunghun Kim. 2013. Personalized defect prediction. In
Proceedings of the 28th IEEE/ACM International Conference on Automated Sofware
Engineering. IEEE, 279–289.
[29] Torsten Joachims. 1998. Text categorization with support vector machines:
Learning with many relevant features. In European Conference on Machine Learn-
ing. Springer, 137–142.
[30] Bryan F Jones, H-H Sthamer, and David E Eyres. 1996. Automatic structural
testing using genetic algorithms. Sofware Engineering Journal 11, 5 (1996),
299–306.
[31] Dennis Kafura and Geereddy R. Reddy. 1987. Te use of sofware complexity
metrics in sofware maintenance. IEEE Transactions on Sofware Engineering 3
(1987), 335–343.
[32] Dongsun Kim, Yida Tao, Sunghun Kim, and Andreas Zeller. 2013. Where should
we fx this bug? a two-phase recommendation model. IEEE Transactions on
Sofware Engineering 39, 11 (2013), 1597–1610.
[33] Sunghun Kim, E James Whitehead Jr, and Yi Zhang. 2008. Classifying sofware
changes: Clean or buggy? IEEE Transactions on Sofware Engineering 34, 2 (2008),
181–196.
[34] Ekrem Kocaguneli, Tim Menzies, Ayse Bener, and Jacky W Keung. 2012. Ex-
ploiting the essential assumptions of analogy-based efort estimation. IEEE
Transactions on Sofware Engineering 38, 2 (2012), 425–438.
[35] Ekrem Kocaguneli, Tim Menzies, and Jacky W Keung. 2012. On the value of
ensemble efort estimation. IEEE Transactions on Sofware Engineering 38, 6
(2012), 1403–1416.
[36] Joseph Krall, Tim Menzies, and Misty Davies. 2015. Gale: Geometric active
learning for search-based sofware engineering. IEEE Transactions on Sofware
Engineering 41, 10 (2015), 1001–1018.
[37] Alex Krizhevsky, Ilya Sutskever, and Geofrey E Hinton. 2012. Imagenet classifca-
tion with deep convolutional neural networks. In Advances in Neural Information
Processing Systems. 1097–1105.
[38] Rakesh Kumar, Keith I Farkas, Norman P Jouppi, Parthasarathy Ranganathan,
and Dean M Tullsen. 2003. Single-ISA heterogeneous multi-core architectures:
Te potential for processor power reduction. In Proceedings of the 36th Annual
IEEE/ACM International Symposium on Microarchitecture. IEEE, 81–92.
[39] An Ngoc Lam, Anh Tuan Nguyen, Hoan Anh Nguyen, and Tien N Nguyen. 2015.
Combining deep learning with information retrieval to localize buggy fles for
bug reports (n). In Proceedings of the 2015 30th IEEE/ACM International Conference
on Automated Sofware Engineering. IEEE, 476–481.
[40] Qoc V Le. 2013. Building high-level features using large scale unsupervised
learning. In 2013 IEEE International Conference on Acoustics, Speech and Signal
Processing. IEEE, 8595–8598.
[41] R´emi Lebret and Ronan Collobert. 2013. Word emdeddings through hellinger
PCA. arXiv preprint arXiv:1312.5542 (2013).
[42] Yann LeCun, Yoshua Bengio, and Geofrey Hinton. 2015. Deep learning. Nature
521, 7553 (2015), 436–444.
[43] Stefan Lessmann, Bart Baesens, Christophe Mues, and Swantje Pietsch. 2008.
Benchmarking classifcation models for sofware defect prediction: A proposed
framework and novel fndings. IEEE Transactions on Sofware Engineering 34, 4
(2008), 485–496.
[44] Lisha Li, Kevin Jamieson, Giulia DeSalvo, Afshin Rostamizadeh, and Ameet
Talwalkar. 2016. Hyperband: a novel bandit-based approach to hyperparameter
optimization. arXiv preprint arXiv:1603.06560 (2016).
[45] Tomas J McCabe. 1976. A complexity measure. IEEE Transactions on Sofware
Engineering 4 (1976), 308–320.
[46] Tim Menzies, Jeremy Greenwald, and Art Frank. 2007. Data mining static code
atributes to learn defect predictors. IEEE Transactions on Sofware Engineering
33, 1 (2007).
[47] Tomas Mikolov, Ilya Sutskever, Kai Chen, Greg S Corrado, and Jef Dean. 2013.
Distributed representations of words and phrases and their compositionality. In
Advances in Neural Information Processing Systems. 3111–3119.
[48] Mohamed Wiem Mkaouer, Marouane Kessentini, Slim Bechikh, Kalyanmoy Deb,
and Mel ´O Cinn´eide. 2014. High dimensional search-based sofware engineer-
ing: fnding tradeofs among 15 objectives for automating sofware refactoring
using NSGA-III. In Proceedings of the 2014 Annual Conference on Genetic and
Evolutionary Computation. ACM, 1263–1270.
[49] Julian Molina, Manuel Laguna, Rafael Mart´ı, and Rafael Caballero. 2007. SSPMO:
A scater tabu search procedure for non-linear multiobjective optimization. IN-
FORMS Journal on Computing 19, 1 (2007), 91–100.
[50] Kjetil Molokken and Magen Jorgensen. 2003. A review of sofware surveys on
sofware efort estimation. In Proceedings of the 2003 International Symposium on
Empirical Sofware Engineering. IEEE, 223–230.
[51] Gordon E Moore and others. 1998. Cramming more components onto integrated
circuits. Proc. IEEE 86, 1 (1998), 82–85.
[52] Lili Mou, Ge Li, Lu Zhang, Tao Wang, and Zhi Jin. 2016. Convolutional Neural
Networks over Tree Structures for Programming Language Processing. In Pro-
ceedings of the Tirtieth AAAI Conference on Artifcial Intelligence. AAAI Press,
1287–1293.
[53] Mahamed GH Omran, Andries Petrus Engelbrecht, and Ayed Salman. 2005.
Diferential evolution methods for unsupervised image classifcation. In 2005
IEEE Congress on Evolutionary Computation, Vol. 2. IEEE, 966–973.
[54] Tomas J Ostrand, Elaine J Weyuker, and Robert M Bell. 2004. Where the bugs
are. In ACM SIGSOFT Sofware Engineering Notes, Vol. 29. ACM, 86–96.
[55] Fabian Pedregosa, Ga¨el Varoquaux, Alexandre Gramfort, Vincent Michel,
Bertrand Tirion, Olivier Grisel, Mathieu Blondel, Peter Pretenhofer, Ron Weiss,
Vincent Dubourg, and others. 2011. Scikit-learn: machine learning in Python.
Journal of Machine Learning Research 12, Oct (2011), 2825–2830.
ESEC/FSE'17, September 4-8, 2017, Paderborn, Germany
Wei Fu, Tim Menzies
[56] Jefrey Pennington, Richard Socher, and Christopher D Manning. 2014. Glove:
global vectors for word representation. In EMNLP, Vol. 14. 1532–1543.
[57] Mukund Raghothaman, Yi Wei, and Youssef Hamadi. 2016. SWIM: synthesizing
what I mean: code search and idiomatic snippet synthesis. In Proceedings of the
38th International Conference on Sofware Engineering. ACM, 357–367.
[58] Radim Rehurek and Petr Sojka. 2010. Sofware framework for topic modelling
with large corpora. In In Proceedings of the LREC 2010 Workshop on New Challenges
for NLP Frameworks. Citeseer.
[59] Jeanine Romano, Jefrey D Kromrey, Jesse Coraggio, Jef Skowronek, and Linda
Devine. 2006. Exploring methods for evaluating group diferences on the NSSE
and other surveys: Are the t-test and Cohenfsd indices the most appropriate
choices. In Annual Meeting of the Southern Association for Institutional Research.
[60] J¨urgen Schmidhuber. 2015. Deep learning in neural networks: An overview.
Neural networks 61 (2015), 85–117.
[61] Ryan Spring and Anshumali Shrivastava. 2017. Scalable and sustainable deep
learning via randomized hashing. In Proceedings of the 23rd ACM SIGKDD Inter-
national Conference on Knowledge Discovery and Data Mining. ACM.
[62] R. Storn and K. Price. 1997. Diferential evolution–a simple and efcient heuristic
for global optimization over continuous spaces. Journal of global optimization
11, 4 (1997), 341–359.
[63] Ilya Sutskever, Oriol Vinyals, and Qoc V Le. 2014. Sequence to sequence
learning with neural networks. In Advances in Neural Information Processing
Systems. 3104–3112.
[64] Chakkrit Tantithamthavorn, Shane McIntosh, Ahmed E Hassan, and Kenichi
Matsumoto. 2016. Automated parameter optimization of classifcation techniques
for defect prediction models. In Proceedings of the 38th International Conference
on Sofware Engineering. ACM, 321–332.
[65] Christopher Teisen, Kim Herzig, Patrick Morrison, Brendan Murphy, and Laurie
Williams. 2015. Approximating atack surfaces with stack traces. In Proceedings
of the 37th International Conference on Sofware Engineering-Volume 2. IEEE,
199–208.
[66] Jakob Vesterstrom and Rene Tomsen. 2004. A comparative study of diferential
evolution, particle swarm optimization, and evolutionary algorithms on numer-
ical benchmark problems. In Proceedings of the 2004 Congress on Evolutionary
Computation, Vol. 2. IEEE, 1980–1987.
[67] Jue Wang, Yingnong Dang, Hongyu Zhang, Kai Chen, Tao Xie, and Dongmei
Zhang. 2013.
Mining succinct and high-coverage API usage paterns from
source code. In Proceedings of the 10th Working Conference on Mining Sofware
Repositories. IEEE, 319–328.
[68] Song Wang, Taiyue Liu, and Lin Tan. 2016. Automatically learning semantic
features for defect prediction. In Proceedings of the 38th International Conference
on Sofware Engineering. ACM, 297–308.
[69] Tiantian Wang, Mark Harman, Yue Jia, and Jens Krinke. 2013. Searching for
beter confgurations: a rigorous approach to clone evaluation. In Proceedings of
the 2013 9th Joint Meeting on Foundations of Sofware Engineering. ACM, 455–465.
[70] Martin White, Michele Tufano, Christopher Vendome, and Denys Poshyvanyk.
2016. Deep learning code fragments for code clone detection. In Proceedings of
the 31st IEEE/ACM International Conference on Automated Sofware Engineering.
ACM, 87–98.
[71] Martin White, Christopher Vendome, Mario Linares-V´asquez, and Denys Poshy-
vanyk. 2015. Toward deep learning sofware repositories. In Proceedings of the
12th Working Conference on Mining Sofware Repositories. IEEE, 334–345.
[72] Andreas Windisch, Stefan Wappler, and Joachim Wegener. 2007. Applying
particle swarm optimization to sofware testing. In Proceedings of the 9th Annual
Conference on Genetic and Evolutionary Computation. ACM, 1121–1128.
[73] David H Wolpert. 1996. Te lack of a priori distinctions between learning
algorithms. Neural computation 8, 7 (1996), 1341–1390.
[74] Bowen Xu, Deheng Ye, Zhenchang Xing, Xin Xia, Guibin Chen, and Shanping Li.
2016. Predicting semantically linkable knowledge in developer online forums via
convolutional neural network. In Proceedings of the 31st IEEE/ACM International
Conference on Automated Sofware Engineering. ACM, 51–62.
[75] Xiao Yang, Craig Macdonald, and Iadh Ounis. 2016. Using word embeddings in
twiter election classifcation. arXiv preprint arXiv:1606.07006 (2016).
[76] Xin Ye, Razvan Bunescu, and Chang Liu. 2014. Learning to rank relevant fles for
bug reports using domain knowledge. In Proceedings of the 22nd ACM SIGSOFT
International Symposium on Foundations of Sofware Engineering. ACM, 689–699.
[77] Zhenlong Yuan, Yongqiang Lu, Zhaoguo Wang, and Yibo Xue. 2014. Droid-
sec: deep learning in android malware detection. In ACM SIGCOMM Computer
Communication Review, Vol. 44. ACM, 371–372.
[78] Yuanyuan Zhang, Mark Harman, and S. Afshin Mansouri. 2007. Te multi-
objective next release problem. In Proceedings of the 9th Annual Conference on
Genetic and Evolutionary Computation. 1129–1137.
[79] Jian Zhou, Hongyu Zhang, and David Lo. 2012. Where should the bugs be fxed?-
more accurate information retrieval-based bug localization based on bug reports.
In Proceedings of the 34th International Conference on Sofware Engineering. IEEE,
14–24.
[80] Guido Zuccon, Bevan Koopman, Peter Bruza, and Leif Azzopardi. 2015. Inte-
grating and evaluating neural word embeddings in information retrieval. In
Proceedings of the 20th Australasian Document Computing Symposium. ACM, 12.
